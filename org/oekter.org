#+SETUPFILE: orgheader.org
#+TITLE: Økter i Programmering og modellering
#+BEGIN_SRC emacs-lisp :exports none :results silent
(add-to-list 'org-html-infojs-options '(sdepth . "2"))
; Her hadde jeg tidligere med tillegget :eval query-export
#+END_SRC


* Terminprosjekt
Dette prosjektet jobber vi med fram til jul, og kommer til å være hovedgrunnlaget for terminkarakteren din.

** Installere bibliotek
- Last ned [[py:arduino_serial.py][arduino_serial.py]], og legg denne i arbeidsmappa di.
- Koble til en arduino med ~Trigger~ satt til pin 13, ~Echo~ til pin 11, ~Gnd~ til gnd og ~Vcc~ til 5 V.
- Kjør det minimale eksempelet under og sjekk at eksempelplot blir laget.

** Minimalt eksempel
#+begin_src python
from arduino_serial import collect_data
import matplotlib.pyplot as plt

tider, ekkotider = collect_data(runtime=5000, delay=2000)

fig, ax = plt.subplots()

graf, = ax.plot(tider, ekkotider)

ax.legend([graf], ["Ekkotider"])
ax.set_xlabel("Eksperimenttid (ms)")
ax.set_ylabel("Måletid (μs)")

fig.savefig('eksempelplot.png')
#+end_src

Her skal vi ha laget oss et 

** Nødvendig utstyr
- Et Arduino-kort
- Ultralydssensor
- Ledninger

** Grovskisse av prosjektoppgave
Du skal utforske numerisk derivasjon (ved for eksempel framoverdifferanse) basert på dataene du får fra Arduino-loggeren.



** Foreslåtte tillegg
- Lage boks med 3D-printer eller laserkutter
- Gjøre målestasjonen trådløs
- Gjøre andre målinger
- Sanntidsvisualisering i Pygame

* Lesing av og skriving til filer

- [[pdf:uke44_innlevering.pdf][Innleveringsoppgaver]]
- [[data:posisjonseksempel.csv][Eksempeldata]]

** Innleveringsoppgaver uke 44 :pdf:
:properties:
:export_file_name: ../pdf/uke44_innlevering.pdf
:end:

*** Innlesing av eksempelfil
Les inn eksempelfila og lagre verdiene i to lister, $tverdier$ og $sverdier$.

*** Plotting av eksempelfil
Plot verdiene fra fila, kall første-aksen for $t (s)$ og andreaksen for $s (m)$. 

*** Derivasjon av eksempelfil
Bruk framoverdifferanse på verdiene fra de foregående oppgavene til å finne en ny liste $vverdier$, merk at denne kommer til å bli ett element kortere enn de to foregående listene.

Plot også disse verdiene, gjerne i samme koordinatsystem.

* Lister og plotting

** Innleveringsoppgaver uke 43 :pdf:
:properties:
:export_file_name: ../pdf/uke43_innlevering.pdf
:end:

*** Et enkelt, dobbelt plot

Velg to funksjoner og plot de innenfor de samme x-verdiene.

Lever fila som ~f"uke43_{fornavn}_dobbelplot.py~ og den resulterende grafen som ~f"uke43_{fornavn}_dobbelplot.png~.

*** Starten på utforsking av framoverdifferansen
Velg én av funksjonene fra forrige oppgave, denne skal du nå gjøre følgende med:

1) Finn funksjonens deriverte /analytisk/, og opprett denne som en egen funksjon
2) Lag et plot som sammenligner den analytiske løsningen med den numeriske tilnærmingen du finner ved å bruke /framoverdifferanse/-metoden fra sist uke.

*** Et eksempel på plotting
#+begin_src python :tangle ../py/uke42_plotting.py :exports none
"""Denne fila er en kort introduksjon til tegning av grafer
i python ved å bruke matplotlib.


Laget av Tarjei.
"""
#+end_src

Om du har tre lister med verdier som skal plottes, en med x-verdier og to med y-verdier, kan du bruke en fremgangsmåte à la følgende for å få til dette.

Inntil videre kan du bruke den følgende fremgangsmåten ukritisk. Bruk hjelpesystemet aktivt om du ønsker å finne andre ting du kan endre med plottene dine, tilstreb ikke å google problemer du eventuelt støter på.


#+begin_src python :tangle ../py/uke42_plotting.py :exports code :results silent
import matplotlib.pyplot as plt

def f(x):
    return x ** 2 - 5

def g(x):
    return x ** 3 + 13


# Vi lager oss en liste [-10, -9, ..., 0, ... 9, 10]
x_verdier = list(range(-10, 11))

# Vi oppretter tomme lister som skal holde y-verdiene våre
y_verdier1 = []
y_verdier2 = []

# Vi legger funksjonsverdiene til y-verdilistene
for x in x_verdier:
    y_verdier1.append(f(x))
    y_verdier2.append(g(x))

# Vi oppretter et tomt plot
fig, ax = plt.subplots()

# Vi lager oss to linjer, en for hver liste av y-verdier. Legg merke til kommaet
linje1, = ax.plot(x_verdier, y_verdier1)
linje2, = ax.plot(x_verdier, y_verdier2)

ax.set_xlabel('x-verdier')
ax.set_ylabel('y-verdier')
ax.set_xlim(-14, 14)
ax.set_ylim(-500, 600)

# Vi setter navn på linjene våre
ax.legend([linje1, linje2], ['f(x)', 'g(x)'])

fig.savefig('eksempelplot.png')
fig.show()
#+end_src

#+begin_src sh :exports none
mv eksempelplot.png ../figurer/uke42_eksempelplot.png
#+end_src

Som produserer følgende plot: 

#+caption: Et enkelt, dobbelt plot
[[file:../figurer/uke42_eksempelplot.png]]

* Hjemmearbeid med funksjoner
<2019-10-16 Wed>

- [[pdf:uke42_innlevering.pdf][Innleveringsoppgaver]]

** Innleveringsoppgaver uke 42 :pdf:
:properties:
:export_file_name: ../pdf/uke42_innlevering.pdf
:end:
*** Tester :noexport:
#+tblname: absoluttdifferansetester
| ~ledd1~ | ~ledd2~ |
|---------+---------|
|       1 |       1 |
|      -5 |      15 |
|      15 |      -5 |
|     -15 |      -5 |
|       0 |      -5 |

*** Introduksjon
Framover, dersom jeg ber deg om å «lage en funksjon ~absolutt_differanse~ som tar to paramaterer og returnerer absoluttverdien av de to parameternes differanse», kan det formelt oversettes til følgende pythonkode:

#+BEGIN_SRC python :session absoluttdifferanse :results silent
def absolutt_differanse(ledd1, ledd2):
    """Returnererer absoluttverdien til differanse mellom 'ledd1' og 'ledd2'."""
    diff = ledd1 - ledd2
    return abs(diff)
#+END_SRC

Etter at du har kjørt programmet, kan du sjekke at funksjonen er opprettet ved å skrive ~help(absolutt_differanse)~ i konsollen. Du skal da få ut noe à la følgende:

#+BEGIN_SRC python :results output code :session absoluttdifferanse :exports results 
print(help(absolutt_differanse))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
Help on function absolutt_differanse in module __main__:

absolutt_differanse(ledd1, ledd2)
    Returnererer absoluttverdien til differanse mellom 'ledd1' og 'ledd2'.
#+END_SRC

Videre kommer jeg til å gi tester funksjonen skal bestå, eksempelvis som i tabellen under.


#+BEGIN_SRC python :var tester=absoluttdifferansetester :session absoluttdifferanse :results raw output :exports results
print("| ~ledd1~ | ~ledd2~ | ~absolutt_differanse(ledd1, ledd2)~ |")
print("|---|")
for test in tester:
    print(f"| {test[0]} | {test[1]} | {absolutt_differanse(test[0], test[1])} |")
#+END_SRC

#+RESULTS:
| ~ledd1~ | ~ledd2~ | ~absolutt_differanse(ledd1, ledd2)~ |
|---------+---------+-------------------------------------|
|       1 |       1 |                                   0 |
|      -5 |      15 |                                  20 |
|      15 |      -5 |                                  20 |
|     -15 |      -5 |                                  10 |
|       0 |      -5 |                                   5 |

Du kan da teste funksjonen din ved å kontrollere at den returnerer riktige verdier, ved for eksempel å skrive i konsollen ~absolutt_differanse(-5, 15)~ for å se at det evaluerer til verdien ~20~.

*** Matematiske funksjoner
#+BEGIN_SRC python :tangle ../py/uke42_matfunk_lf.py :exports none
"""Dette programmet skriver ut en enkel funksjonstabell
for den matematiske funksjonen
f(x) = 3 * x ** 2 * lg(x) - 15

Laget av Tarjei
"""

#+END_SRC
Som andre navn i python, tilstreber vi at også funksjonsnavnene er så beskrivende som mulig. Bokstaver er billige, og du har lettere for å forstå hva funksjonen ~kvadratrot~ gjør, enn ~frt~.

Unntaket til dette er når vi definere enkle matematiske funksjoner, som $f(x) = 3x^2\cdot\lg x - 15$. Vi ville altså fått:

#+BEGIN_SRC python :session matfunk :exports code :results silent :tangle ../py/uke42_matfunk_lf.py
import math

def f(x):
    return 3 * x ** 2 * math.log10(x) - 15
#+END_SRC

(Her har jeg også droppet å ta med en dokumentasjonsstreng.)

#+begin_task
Bruk funksjonen over og lag et program som skriver ut ti \(x\)- og tilhørende \(f(x)\)-verdier for funksjonen over.
#+end_task

For \(x\)-verdiene fra og med 20, til og med 29, får vi altså følgende utskrift:
#+BEGIN_SRC python :session matfunk :exports results :results output code :tangle ../py/uke42_matfunk_lf.py
x = 20
print("   x     --     f(x)   ")
print("-----------------------")
while x <= 29:
    f_av_x = f(x)
    print(f"{x}    --    {f_av_x:.1f}")
    x += 1
     
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
x     --     f(x)   
-----------------------
20    --    1546.2
21    --    1734.3
22    --    1934.2
23    --    2146.1
24    --    2370.0
25    --    2606.1
26    --    2854.6
27    --    3115.4
28    --    3388.7
29    --    3674.6
#+END_SRC

Kall fila ~f"uke42_{fornavn}_matfunk.py"~ (altså, ~uke41_trond_matfunk.py~, om du er så heldig å hete Trond).

*** Typer og funksjonstyper
#+BEGIN_SRC python :tangle ../py/uke42_typer_lf.py :exports none
"""Dette programmet lister opp typen til noen ulike verdier.

Laget av Tarjei
"""
def utregning(x):
    """Tar inn et tall x, og gjør litt matte."""
    dobbel_x = 2 * x
    litt_mindre = dobbel_x - 5
    return litt_mindre * dobbel_x

def er_stort(testtall, stort_tall):
    """Tar inn to tall og returnerer hvorvidt 'testtall'
    er større enn 'stort_tall'.
    """
    returverdi = False
    if testtall > stort_tall:
        returverdi = True
    return returverdi


# I alle linjene under, fyll ut det som står i anførselstegn
# når du skriver venstre side inn i konsollen.

# Eksempel:
# type(3.1) == 'float'
# siden
# >>> type(3.1)
# <class 'float'>

# Oppgaver:
# type(3) == 'int'
# type(2 + 2) == 'int'
# type(utregning(5)) == 'int'

svar = utregning(5)

# type(svar) == 'int'
# type(er_stort(3, 2)) == 'bool'
# type(er_stort(2, 3)) == 'bool'
# type(er_stort) == 'function'
#+END_SRC

Vi har tidligere snakket om at ulike verdier har ulike /type/. For eksempel er ~3~ av typen ~int~, altså et heltall eller «integer». Vi skal nå se på litt flere typer, blant annet /funksjoner/.

#+begin_task
Skriv av det følgende pythonprogrammet og fyll ut det som står de doble likhetstegnene, lever fila som ~f"uke42_{fornavn}_typer.py~.
#+end_task

#+BEGIN_SRC python :exports code
def utregning(x):
    """Tar inn et tall x, og gjør litt matte."""
    dobbel_x = 2 * x
    litt_mindre = dobbel_x - 5
    return litt_mindre * dobbel_x

def er_stort(testtall, stort_tall):
    """Tar inn to tall og returnerer hvorvidt 'testtall'
    er større enn 'stort_tall'.
    """
    returverdi = False
    if testtall > stort_tall:
        returverdi = True
    return returverdi


# I alle linjene under, fyll ut det som står i anførselstegn
# når du skriver venstre side inn i konsollen.

# Eksempel:
# type(3.1) == 'float'
# siden
# >>> type(3.1)
# <class 'float'>

# Oppgaver:
# type(3) == 
# type(2 + 2) ==
# type(utregning(5)) ==

svar = utregning(5)

# type(svar) ==
# type(er_stort(3, 2)) ==
# type(er_stort(2, 3)) == 
# type(er_stort) == 
#+END_SRC

*** Derivering av funksjoner
#+BEGIN_SRC python :tangle ../py/uke42_framoverdiff_lf.py :exports none
"""Dette programmet regner ut den deriverte av en enkel matematiske funksjon
ved en del ulike x-verdier.

Laget av Tarjei
"""
#+END_SRC

Fra matematikken er vi vant til å innføre den deriverte via dens /definisjon/.

#+begin_definition
Den derivert til funksjonen $f(x)$ ved punktet $x=a$ finner vi som \[f(x) = \lim_{\Delta x \to 0}\frac{f(x+\Delta x) - f(x)}{\Delta x}\]
#+end_definition

Vi skal nå bruke denne definisjonen til å regne ut den deriverte for en matematisk funksjon, \(f(x) = 3x^2 \cdot \lg x - 15\).

Om jeg ønsker å finne verdien til den deriverte av denne funksjonen i, for eksempel, \(x = 4\), kan vi finne et bedre og bedre overslag for dette ved å bruke mindre og mindre verdier for $\Delta x$.

#+BEGIN_SRC python :session framoverdiff :exports both :tangle ../py/uke42_framoverdiff_lf.py :results output code
import math

def f(x):
    return 3 * x ** 2 * math.log10(x) - 15

delta_x = 0.001    # velger en veldig liten verdi for delta x
eval_x = 4
delta_f = f(eval_x + delta_x) - f(eval_x)

derivert = delta_f / delta_x

print(f"Den deriverte av funksjonen ved x = {eval_x} er omtrent {derivert:.2f}.")
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
Den deriverte av funksjonen ved x = 4 er omtrent 19.66.
#+END_SRC

Denne måten å regne ut en derivert på kalles en /framoverdifferanse/, siden vi finner den deriverte i \(x\) ved å /legge til/ \(\Delta x\).

#+begin_task
Utvid tabellen fra forrige oppgave til også å ha en kolonne for den deriverte av funksjonen ved de ulike \(x\)-verdiene. Bruk /framoverdifferanse/ for å finne den deriverte. Lever fila som ~f"uke42_{fornavn}_framoverdiff.py~.
#+end_task

#+BEGIN_SRC python :session framoverdiff :exports results :results output code :tangle ../py/uke42_framoverdiff_lf.py

x = 20
print("   x     --     f(x)     --     f'(x)")
print("-------------------------------------")
while x <= 29:
    f_av_x = f(x)
    der_av_f_ved_x = (f(x+delta_x) - f(x)) / delta_x
    print(f"{x}    --    {f_av_x:.1f}    --    {der_av_f_ved_x:.2f}")
    x += 1
     
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
x     --     f(x)     --     f'(x)
-------------------------------------
20    --    1546.2    --    182.19
21    --    1734.3    --    193.97
22    --    1934.2    --    205.87
23    --    2146.1    --    217.89
24    --    2370.0    --    230.03
25    --    2606.1    --    242.27
26    --    2854.6    --    254.62
27    --    3115.4    --    267.07
28    --    3388.7    --    279.61
29    --    3674.6    --    292.25
#+END_SRC

*** Utfordring: Derivasjonsfunksjon
#+begin_src python :exports none :results silent :tangle ../py/uke42_framoverdiffunk_lf.py
"""Dette programmet regner ut den deriverte av en enkel matematisk funksjon
ved å å bruke en egen derivasjonsfunksjon.

Laget av Tarjei
"""
import math

def derivert_av_funk_ved_x(funksjon, x):
    """Returnerer den numeriske verdien av den deriverte av funksjonen
    'funksjon' når x er 'x'.

    Bruk en 'framoverdifferanse' (se forrige oppgave) med 'delta_x = 0.0001'.

    Eksempel:
    def f(x):
        return x ** 2

    >>> derivert_av_funk_ved_x(f, 2)   =>  4.0001000000078335

    """
    delta_x = 0.0001
    return (funksjon(x + delta_x) - funksjon(x)) / delta_x


# Vi kan nå teste funksjonen for de samme verdiene av x, med vår gamle f

def f(x):
    return 3 * x ** 2 * math.log10(x) - 15

x = 20
print("   x     --     f(x)     --     f'(x)")
print("-------------------------------------")
while x <= 29:
    f_av_x = f(x)
    der_av_f_ved_x = derivert_av_funk_ved_x(f, x)
    print(f"{x}    --    {f_av_x:.1f}    --    {der_av_f_ved_x:.2f}")
    x += 1

#+end_src

Lag en funksjon med følgende spesifikasjon:

#+BEGIN_SRC python
def derivert_av_funk_ved_x(funksjon, x):
    """Returnerer den numeriske verdien av den deriverte av funksjonen
    'funksjon' når x er 'x'.

    Bruk en 'framoverdifferanse' (se forrige oppgave) med 'delta_x = 0.0001'.

    Eksempel:
    def f(x):
        return x ** 2

    >>> derivert_av_funk_ved_x(f, 2)   =>  4.0001000000078335

    """

    # Her gjør du utregningene dine
#+END_SRC

Merk, her sender vi /navnet til en funksjon/ inn som en parameter til funksjonen.

#+begin_task
Lag en funksjon som tar inn navnet på en funksjon og en \(x\)-verdi. Returner et overslag for den deriverte til funksjonen ved denne \(x\)-verdien ved hjelp av framoverdifferanse med en \(Delta x = 0.0001\). Lever fila som ~f"uke42_{fornavn}_framoverdiffunk.py~.
#+end_task

* Introduksjon til funksjoner
<2019-10-09 Wed>
- [X] :: Abstraksjon som et alternativ til kodenivå
- [X] :: Hvordan lage («definere») en funksjon i Python
- [X] :: Hvordan bruke («kalle») en funksjon i Python

* Videre med algoritmer
<2019-09-25 Wed>
- [X] Repetisjon fra sist
- [ ] En tilnærming til likningsløsning

- [[pdf:uke39_innlevering.pdf][Innleveringsoppgaver]]
- [[pdf:uke39_repetisjon.pdf][Repetisjonsoppgaver]]
- [[pdf:uke39_innlevering_alternativ.pdf][Alternative innleveringsoppgaver]] (mer krevende)

** Repetisjonsoppgaver uke 39 :noexport:
:properties:
:export_file_name: ../pdf/uke39_repetisjon.pdf
:end:

Ved siden av å gå gjennom de tidligere innleveringsoppgavene, kan du sjekke om du er ajour med faget ved å prøve deg på følgende oppgaver. Om du ønsker besvarelsen din kommentert, kan du levere den filvis som angitt i slutten av hver del.

*** Enkel regning og konsollen
Bruk konsollen til å regne ut følgende:
1. $3^2 - 15 + \frac{1}{4}$
2. Resten av delestykket $\frac{11233212332}{43434}$
3. Lag en variabel ~a~, gi den verdien 5,  og sjekk om den er større enn 3.
4. Sjekk om variabelen ~a~ er delelig på 2 eller om den er større enn 2.

Fasit:
1. $-5,75$
2. $7214$
3. ~True~
4. ~True~

*** input og printing
Skriv et program der du ber brukeren om to heltall. Bruk ulike regneoperasjoner og skriv svarene tilbake til brukeren. For eksempel:

#+BEGIN_SRC python :exports code
# Be brukeren om tallene tall1 og tall2 her
# husk å endre til heltall

prod = tall1 * tall2

print(f"Produktet av {tall1} og {tall2} er {prod}.")
#+END_SRC

Filnavn ~uke39_rep_inputprint_fornavn.py~.

*** Forgreining
Skriv et program som ber brukeren om to heltall, skriv tilbake hvilket tall som er størst og hvilket som er minst.

Filnavn ~uke39_rep_forgreining_fornavn.py~.

*** Løkker
Skriv et program som ber brukeren om et tall, og som deretter teller fra 0 opp til tallet brukeren har tastet inn.

Utvid programmet til å hoppe over alle tallene som er i 7-gangeren.


Filnavn ~uke39_rep_loekker.py~.

** Innleveringsoppgaver uke 39 :noexport:
:properties:
:export_file_name: ../pdf/uke39_innlevering.pdf
:end:
Skriv et program som bruker halveringsmetoden til å løse en selvvalgt likning. Pass på å skrive i dokumentasjonen hva programmet skal løse. Starten på et eksempel kan se ut som følger:

#+BEGIN_SRC python :exports code
# Dette programmet bruker halveringsmetoden til å løse likningen
# 
# x**5 - 3*x**2 = 15, som altså kan omformes til
# x**5 - 3*x**2 - 15 = 0
#
# Det er skrevet av Tarjei, 25. september 2019.


# Velger en startverdi for løsningen som forsikrer at venstre
# side er _negativ_
x0 = 0

# Velger en startverdi for løsningen som forsikrer at venstre
# side er _positiv_
x1 = 10

# Velger en godkjent 'feil', altså hvor nøyaktig jeg mener svaret må være.
epsilon = 1E-7

while abs(x1-x0) > epsilon:
    m = (x1 + x0)/2
    # Her gjør du utregningene dine.

print(f"Løsningen av likningen er {m}".)
#+END_SRC

Lever oppgaven som ~uke39_fornavn.py~.

** Alternative innleveringsoppgaver uke 39 :noexport:
:properties:
:export_file_name: ../pdf/uke39_innlevering_alternativ.pdf
:end:
Vi kan bruke en ~while~-løkke til å løse en generell likning via halveringsmetoden. Om du ikke husker hvordan dette gjøres, se på de andre oppgavene først.

Du skal lage et program hvor du bruker halveringsmetoden til å gjøre følgende:
- Regne ut vilkårlige røtter for vilkårlige tall, altså $\sqrt[b]{a}$.
- Regne ut tierlogaritmen for et vilkårlig tall, altså $\lg{a}$.
- Regne ut den naturlige logaritmen for et vilkårlig tall, altså $\ln{a}$.
- Regne ut en vilkårlig logaritme for et vilkårlig tall, altså $\log_b{a}$.

* Algoritmer
<2019-09-18 Wed>
- [X] Repetisjon fra sist
- [ ] Funksjoner uten «bieffekter»
- [ ] Funksjoner som enkelt repeterbare kodeblokker
- [ ] Lister
- [ ] Et første plot med lister

[[pdf:uke38_innlevering.pdf][Innleveringsoppgaver]]

** Tillegg fra undervisningen
Det blei mye knoting rundt kvadrotutregningene denne økta. Her er en gjennomgang gjennomgang av det jeg ønsket å få ut av den initielle delen.

Dette er for øvrig en algoritme for utregning av kvadratrøtter som kalles /babylonsk tilnærming/, og den første kjente nedtegnelsen er fra år 60 evt.

[[https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method][Wikipedia]] for de spesielt interesserte.

*** Motivasjon
I en datamaskin er det en del regning som gjøres direkte på maskinvaren. I moderne maskiner er det for eksempel egne kretser som regner ut summen av to tall eller produktet av to tall. Det er dog et utall regneoperasjoner maskinen må kjøre flere ganger gjennom ulike kretser for å komme fram til. Si vi for eksempel ønsker å finne $\sqrt{13}$, eller $\sqrt[3]{13}$, eller generelt $\sqrt[48]{13}$, her må maskinen gjøre en serie med operasjoner, den må følge en /algoritme/, for å finne svaret.

*** Enkelt implementert i Python
Vi er heldige, vi skriver ikke koden direkte til maskinen, vi skriver koden i python som så oversettes via en del trinn til kode som kjøres på maskinen. Dette forenkler ting voldsomt. Om vi ønsker å finne løsningene over, er ikke det værre enn å gjøre noe à la følgende:

#+BEGIN_SRC python :exports both
from math import sqrt
kvadratrot = sqrt(13)
tredjerot  = 13 ** (1 / 3)
foertiaattenderot = 13 ** (1 / 48)

print(f"Kvadratroten av 13 er {kvadratrot}.")
print(f"Tredjeroten av 13 er {tredjerot}.")
print(f"48.-roten av 13 er {foertiaattenderot}.")
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Kvadratroten av 13 er 3.605551275463989.
Tredjeroten av 13 er 2.3513346877207573.
48.-roten av 13 er 1.0548899460507581.
#+END_SRC

Hva skal vi gjøre om vi kun kan opphøye i heltall?

*** En vanskeligere implementasjon i Python
Om vi skal finne $\sqrt{S}$, kan vi tenke oss at det vi skal finne er løsningen på likninga \[S = x^2.\] Vi lar fremgangsmåten vår være som følger:

1) Gjør en gjetning for $x_0$ ($0$ markerer at dette er utgangspunktet, vi setter her $x_0 = 1$)
2) Sjekk om nåværende gjetning er tilstrekkelig nærme løsningen ved å regne ut $x_n^2$ og sammenligne dette med $S$, hvor $x_n$ er nåværende gjetning.
3) Hvis $x_n$ var tilstrekkelig nærme, du er ferdig; hvis ikke, oppdater til $x_{n+1}$ ved å bruke $x_{n+1} = \frac{x_n + \frac{S}{x_n}}{2}$.
4) Gå tilbake til punkt 2.

Punkt 2 til punkt 4 dekker vi i Python ved å bruke en ~while~-løkke, hvor testen i løkka er hvorvidt gjetningen nå er «tilstrekkelig nære». Hva skal vi sette til å være «tilstrekkelig nære»? Vel ... det er helt opp til deg. Dersom vi lar forskjellen mellom $x_n^2$ og $S$ være «feilen» i gjetningen vår, kan vi si at vi kjører algoritmen til denne feilen har blitt liten nok. Vi bryr oss ikke om feilen er positiv eller negativ, vi er kun interessert i hvor stor den er.

Om vi skriver inn hele dette programmet i python, kan det se ut som følger:

#+BEGIN_SRC python :exports both

S = 13            # verdien vi skal finne kvadratroten av
x = 1             # vår initielle gjetning på løsningen
epsilon = 0.00001 # hva vi godkjenner som "nære nok"
i = 0             # bruker denne for å holde orden på antall runder i løkka

print(f"Starter med gjetningen {x}.")
print("--------------------------------------------------------")


while abs(S - x**2) > epsilon:      # Her sjekker vi om nåværende gjetning er nære nok
    i += 1                          # Merker oss at vi går inn i løkka nok en gang
    x = (x + S/x) / 2               # Denne linja er kommentert i et eget avsnitt under
    print(f"Runde nr. {i} gjennom løkka.")
    print(f"Nåværende gjetning er {x}, etter oppdatering.")
    print(f"Dette er egentlig kvadratroten av {x**2}.")
    print(f"Feilen vår er dermed nå {abs(S - x**2)}.")
    print("--------------------------------------------------------")

# Vi har nå kommet oss ut av while-løkka
# altså må gjetningen ha blitt god nok
print(f"Kvadratroten av {S} er {x}.")
print(f"Vi har da fått en feil på {abs(S - x**2)}.")
print(f"Vi var gjennom løkka {i} ganger.")
#+END_SRC

#+RESULTS:
Starter med gjetningen 1.
--------------------------------------------------------
Runde nr. 1 gjennom løkka.
Nåværende gjetning er 7.0, etter oppdatering.
Dette er egentlig kvadratroten av 49.0.
Feilen vår er dermed nå 36.0.
--------------------------------------------------------
Runde nr. 2 gjennom løkka.
Nåværende gjetning er 4.428571428571429, etter oppdatering.
Dette er egentlig kvadratroten av 19.612244897959187.
Feilen vår er dermed nå 6.612244897959187.
--------------------------------------------------------
Runde nr. 3 gjennom løkka.
Nåværende gjetning er 3.6820276497695854, etter oppdatering.
Dette er egentlig kvadratroten av 13.557327613667736.
Feilen vår er dermed nå 0.5573276136677361.
--------------------------------------------------------
Runde nr. 4 gjennom løkka.
Nåværende gjetning er 3.6063454894655185, etter oppdatering.
Dette er egentlig kvadratroten av 13.00572778938829.
Feilen vår er dermed nå 0.005727789388290105.
--------------------------------------------------------
Runde nr. 5 gjennom løkka.
Nåværende gjetning er 3.6055513629176015, etter oppdatering.
Dette er egentlig kvadratroten av 13.000000630636974.
Feilen vår er dermed nå 6.306369737529849e-07.
--------------------------------------------------------
Kvadratroten av 13 er 3.6055513629176015.
Vi har da fått en feil på 6.306369737529849e-07.
Vi var gjennom løkka 5 ganger.


Legg merke til at det aller meste av koden her går til å skrive ut informasjon til brukeren.

*** Hvorfor fungerer oppdateringen?
Når vi oppdaterer med \[x_{n+1} = \frac{x_n + \frac{S}{x_n}}{2},\] altså at den oppdaterte gjetningen $x_{n+1}$ er gjennomsnittet av $x_n$ og $\frac{S}{x_n}$ bruker vi følgende argumentasjon:

- Dersom $x_n$ er en /for lav/ gjetning, altså at $x_n^2 < S$, vil $\frac{S}{x_n}$ være en /for høy/ gjetning. Altså er løsningen et sted mellom de to.
- Dersom $x_n$ er en /for høy/ gjetning, altså at $x_n^2 > S$, vil $\frac{S}{x_n}$ være en /for lav/ gjetning. Altså er løsningen et sted mellom de to.

Vi kan dermed komme oss nærmere en faktisk løsning ved å teste ut gjennomsnittet av de to.

** Innleveringsoppgaver uke 38 :noexport:
:properties:
:export_file_name: ../pdf/uke38_innlevering.pdf
:end:

Ved å bruke designmønsteret fra [[py:uke38_sqrt.py][kvadratrotutregningene]] lag et program som gjør følgende:
- Ber brukeren om to /heltall/
- Regner ut /produktet/ av de to tallene
- Regner ut /kvotienten/ til de to tallene (det første delt på det andre, hvor du bruker heltallsdivisjon)
- Regner ut /resten/ til divisjonen av det første delt på det andre tallet

Her må du tenke etter hvilken test du ønsker å bruke.

Av regneoperasjoner, får du kun bruke /addisjon/ og /subtraksjon/.

* Løkker
<2019-09-11 Wed>
- [X] Recap fra sist
- [X] ~While~-løkker

[[pdf:uke37_innlevering.pdf][Innleveringsoppgaver]]

Her er et foreslått [[py:uke37_lf.py][løsningsforslag]] til innleveringsoppgavene.
** Innleveringsoppgaver uke 37 :noexport:
:properties:
:export_file_name: ../pdf/uke37_innlevering.pdf
:end:
*** Collatz' formodning
Lag et program som ber brukeren om et tall, og som skriver ut tallene som følger fra dette tallet fra Collatz' formodning.

#+begin_definition
Collatz' formodning

Hvis $n$ er et partall, del det på 2. Hvis $n$ er et oddetall, gang det med 3 og legg til 1.
#+end_definition

#+begin_example
>>> n = 5
5
16
8
4
2
1
#+end_example

*** Utfordring
Eksempelet over viser at ~5~ går innom seks verdier før det lander på ~1~ (~5 16 8 4 2 1~). Hvilket tall under 10000 går innom flest verdier før det lander på ~1~?
* Forgreining
<2019-09-04 Wed>
- [X] Recap om basisregning
- [X] Input fra bruker
- [X] ~if~-setninger
- [X] Indentering og blokkstruktur

[[pdf:uke36_innlevering.pdf][Innleveringsoppgaver]]

** Kommentarer fra sist
- Husk å importere biblioteker i fila du leverer, det du gjør i konsollen følger ikke med leveringa.

** Innleveringsoppgaver uke 36 :noexport:
:properties:
:export_file_name: ../pdf/uke36_innlevering.pdf
:end:
*** Andregradsløser
Lever en fil ~uke36_ditt_navn.py~ hvor du løser følgende oppgave:

Du skal lage et program som ber brukeren om tre tall, ~a~, ~b~, og ~c~. Programmet ditt skal så løse likningen \[ax^2 + bx + c = 0\] og skrive svaret eller svarene ut for brukeren.

*** Tilleggsutfordring: Faktorisering 
Utvid programmet slik at det skriver ut det faktoriserte uttrykket for brukeren.

* Grunnleggende regning
<2019-08-21 Wed>
- [X] Basisregning
- [X] ~.py~-filer
- [X] Typer
- [ ] Funksjoner og funksjonssignaturer

[[pdf:uke33_innlevering.pdf][Innleveringsoppgaver]]
** Innleveringsoppgaver uke 34 :noexport:
:properties:
:export_file_name: ../pdf/uke34_innlevering.pdf
:end:
Lever en fil ~uke34_ditt_navn.py~ hvor du regner ut og skriver ut svarene til følgende oppgaver:

1) $2\cdot2$
2) $2 + 3^{51} - 17$
3) Antall tegn i teksstrengen «dette er en mellomlang setning som er skrevet via innfallsmetoden».
4) $\sqrt{17}$ med tre siffer etter desimaltegnet.

Svarene dine skal altså se ut som følger:
#+BEGIN_SRC python :exports results
from math import sqrt
print(2 * 2)
print(2 + 3 ** 51 - 17)
print(len("dette er en mellomlang setning som er skrevet via innfallsmetoden"))
print(f"{sqrt(17):.3f}")
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
4
2153693963075557766310732
65
4.123
#+END_SRC

Lykke til!
