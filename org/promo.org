#+SETUPFILE: orgheader.org
#+PROPERTY: header-args :eval never-export :results silent
#+TITLE: Programmering og modellering X

#+BEGIN_EXPORT html
<script type="text/javascript" language="JavaScript"> org_html_manager.set("BASE_URL_QUESTIONS", "https://github.com/tarjeiba/promo/issues/new/");</script>
#+END_EXPORT

#+BEGIN_SRC emacs-lisp :eval query-export :exports none
(add-to-list 'org-html-infojs-options '(sdepth . "2"))
#+END_SRC

* Introduksjon
:PROPERTIES:
:CUSTOM_ID: intro
:END:
Prosessoren (CPU-en) i en rimelig datamaskin kan i dag gjennomføre over 10 milliarder desimaltallsoperasjoner hvert sekund. Hold en ball en meter over bakken. Fra du slipper ballen, til den treffer bakken, kan datamaskinen din fylle ut en gangetabell som går fra 1 til 45 000.

Datamaskiner endrer spillereglene /fullstendig/.

# #+CAPTION: Slipp en ball fra en meter. Regn!
# #+ATTR_HTML: :alt Alt går i ball :align right :width 100px
# [[fig:tegning_regneball.png]]

Personlig tror jeg ikke det er essensielt at hver og en av oss må kunne programmere disse maskinene. Jeg tror dog det er viktig, og at det stadig blir viktigere, at vi veit hvilke muligheter programmeringen åpner for. Nesten uavhengig av hvilket fagfelt du jobber innenfor, finnes det oppgaver som best lar seg løse med programmering.

Programmering i seg selv er en ferdighet uten andre krav til forkunskaper enn at du må kunne lese og skrive. For de fleste byr allikevel programmering på en bratt læringskurve. Datamaskiner er ufattelig gode til noen ting, spesielt regning, og tilsvarende dårlig til andre. Der vi kan lese en setning som «dnene steningen ihonnelder neon fiel», vil ~if x == 2~ og ~if x = 2~ kunne være forskjellen på et dataprogram som fungerer og et som ikke fungerer.

Som spirende programmerer kommer du til å kjenne på både frustrasjon og irritasjon, men forhåpentligvis en overvekt av mestringsfølelse og glede. I starten bruker vi gjerne tre timer på å automatisere en jobb det ville tatt oss fem minutter å gjøre for hånd. Tro meg uansett når jeg sier at følelsen når kodesnutten kjører uten feilmelding etter tre timers jobb gjør det mer enn verdt investeringa.

Lykke til!

** Et første program
Før vi gjør noe annet, kan vi ha et kort førstemøte med Python. Om du er på en Windows-maskin med Python installert (er du elev i Osloskolen, skal det være tilfellet) kan du trykke på Windows-knappen på tastaturet, skrive «cmd» i feltet som kommer opp, trykke enter, og forhåpentligvis få opp noe à la følgende.

#+CAPTION: Kommandolinja til Windows
[[fig:cmd-vindu.png]]

I det vinduet skal du nå kunne skrive «python» og trykke enter. Du bør få opp litt tekst og til slutt en linje som viser ~>>>~.

Forsøk å skrive følgende linjer og trykk enter etter hver.

#+BEGIN_EXAMPLE
>>> print("Hei, verden!")
#+END_EXAMPLE

#+BEGIN_EXAMPLE
>>> 2 + 2
#+END_EXAMPLE

#+BEGIN_EXAMPLE
>>> 2 + 2 == 5
#+END_EXAMPLE

#+BEGIN_EXAMPLE
>>> # print("Hei, verden!")
#+END_EXAMPLE

Du bør ha fått noe lignende det under tilbake.

#+BEGIN_EXAMPLE
Hei, verden!
4
False

#+END_EXAMPLE

I så fall, godt jobba! Du har nå begynt å skrive litt Python. Vi kommer snart tilbake til hvordan jeg ønsker at du skal jobbe med kodesnuttene som står på denne sida mens du jobber deg gjennom temaene.

** Faget
Denne sida er opprinnelig skrevet for faget /Programmering og modellering X/ slik det fremstår ved skolestart høsten 2018. Vi har da følgende læremål å forholde oss til:

*Grunnleggende programmering*
- gjøre rede for overgangen mellom høynivåkode og lavnivåkode
- omgjøre problemstillinger til konkrete delproblemer, vurdere hvilke delproblemer som lar seg løse digitalt, og utforme løsninger for disse
- bruke grunnleggende programmering som variabler, datatyper, løkker, tester, plotting, tilfeldige tall, funksjoner og enkel brukerinteraksjon
- lage strukturerte og oversiktlige programmer med hensiktsmessige kommentarer

*Matematiske metoder*
- lage programskisser og algoritmer med utgansgpunkt i et matematisk problem
- bruke og utlede numeriske metoder for å derivere og integrere funksjoner
- bruke og utlede metoder for å finne nullpunter til funksjoner
- bruke og utlede numeriske metoder til å løse differensiallikninger
- sammenligne noen analytiske og numeriske metoder

*Modellering*
- utforme matematiske modeller med utgangspunkt i praktiske problemstillinger og vurdere modellene
- gjøre rede for modellbegrepet og drøfte ulemper og fordeler ved noen modeller
- sammenligne resultater fra simuleringer med eksperimentelle data
- planlegge, utføre, drøfte og presentere et selvstendig arbeid knyttet til modellering

Dette er hårete, men gjennomførbare, mål for et «tretimersfag». For de av dere som har gledet seg til å lære å programmere, er det /grunnleggende programmering/ som i hovedsak dekker dette. Her skal vi lære ting som er essensielle for /all/ programmering, uavhengig av bruksområde. Gjennom arbeidet innenfor disse temaene, skal vi forsøke å legge et solid programmeringsgrunnlag, som du skal kunne bruke på hjemmeprosjekter, når du sitter på studiebenken og har valgt informatikk som fagfelt eller når du jobber som ingeniør.

** Opplegg
Vi legger opp en prosjektbasert gjennomgang. Når man hører om at lister i Python er «muterbare», at funksjoer kan ha «bieffekter» eller at ~self~ viser til instansen av klassen som kjører metoden, er det nyttig om du ser behovet for disse fagbegrepene i et arbeid du holder på med.

Vi kommer til å ha to prosjekter på høsten og to på våren. Jeg kommer til å legge noen anbefalinger for hvilke prosjekter dette kan være, men jeg er åpen for forslag om du har noe annet du kunne tenkt deg å se nærmere på.

* Bruk av nettsida
:PROPERTIES:
:CUSTOM_ID: bruk
:END:
Denne nettsida er bygd opp rund å skulle kunne være fullstendig tastaturnavigerbar.

Du kan til enhver tid skrive «?» på tastaturet for å få opp en hjelpeside. /Bruk den./

Jeg har med vilje ikke lagt inn noe kommentarfelt til hvert kapittel, men ønsker at du flittig bruker spørrefunksjonen som har tastatursnarvei «q». Du vil da tas til [[https://github.com][Github]], en sosial nettside for programmering, hvor denne sida ligger lagret. Still spørsmålet ditt der, så vil forhåpentligvis noen snarlig kunne hjelpe deg. Spesielt relevante spørsmål legger jeg lenke til ved de temaene det gjelder.

Koden til hvert kapittel ligger tilgjengelig som egen fil under hver kapitteloverskrift. Jeg anbefaler dog at du kun bruker denne direkte om du virkelig står fast. Forsøk først å skrive av eventuell kode direkte fra nettsida, da dette gjør at du får en bedre forståelse av hva programmet gjør og hvordan det fungerer.

#+BEGIN_QUOTE
Hvorfor i all verden ser den så dårlig ut på mobil?
-- ukjent elev, 2018
#+END_QUOTE


#+BEGIN_QUOTE
Jeg jobber med saken.
-- Tarjei Bærland, 2018
#+END_QUOTE

* Matematikk og programmering
:PROPERTIES:
:CUSTOM_ID: matematikkogprogrammering
:END:
** Programmering
:PROPERTIES:
:CUSTOM_ID: programmering
:END:
Når vi programmerer, setter vi opp et sett med instrukser til datamaskinen. Disse instruksene er en trinnvis gjennomgang av hvordan maskinen skal løse et problem.

Med en fiktiv maskin som i utgangspunktet kun kan legge sammen og trekke fra, hva forsøker vi å få maskinen til å gjøre via trinnene under?

#+BEGIN_EXAMPLE
sett a til å være tallet 5
sett b til å være tallet 3
sett svar til å være tallet 0

så lenge b er større enn null, gjør følgende:
    oppdater svar ved å legge til a
    senk verdien til b med 1
#+END_EXAMPLE

Hva vil verdien til ~svar~ være når dette programmet har kjørt ferdig?

** Matematikk
:PROPERTIES:
:CUSTOM_ID: programmering
:END:
Det forrige eksempelet ville vi løst matematisk ved å skrive opp følgende uttrykk:

$$ \textrm{svar} = 5 + 5 + 5 = 5 \cdot 3 $$

~svar~ har altså verdien 15. Her forteller vi ikke lenger hvordan det skal regnes ut, vi sier bare hva ~svar~ er.

Dette kunne vi gjort i de aller fleste programmeringsspråk òg, i Python ville det for eksempel sett ut som følger:

#+BEGIN_SRC python :exports code :results silent
a = 5
b = 3
svar = a * b
#+END_SRC

Som da ville gitt oss...

#+BEGIN_SRC python :exports both
print(svar)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
15
#+END_SRC

Dette kan vi gjøre fordi Python kommer med gangefunksjonen innebygd. Det dukker dog raskt opp matematiske påstander vi ikke kan løse uten en trinnvis prosess.

Et enkelt matematisk spørsmål kan for eksempel være at «hva er produktet av de førti første primtallene?» Dette har vi i de aller fleste programmeringsspråk ikke direkte måte å løse, vi må fortelle maskinen hva den skal gjøre instruks for instruks.
* Programmeringsspråk
:PROPERTIES:
:CUSTOM_ID: programmeringsspraak
:END:
Vi skal gjennom arbeidet i denne [[popup:jeg kommer ikke på noe bedere å kalle det][boka]] bruke programmeringsspråket Python.

Det er mange gode grunner til å velge Python, vi skal gå gjennom noen av dem straks, men vit med sikkerhet det at vi like så godt kunne valgt et annet språk.

** Valg av språk
Det finnes et utall programmeringsspråk. Noen språk er bedre egnet enn andre for visse oppgaver, intet språk er best på alt. Om du veit at det eneste du skal jobbe med er statistikk, ville kanskje det rette valget for deg være språket R; om du skal jobbe med Arduino bør du bli kjent med C++; om du ikke liker den imperative fremgangsmåten de fleste språk byr på, men ønsker en mer /funksjonell/ tilnærming, plukk opp Haskell; elsker du parenteser, se nærmere på Lisp; vil du skrive programmer som kjører i nettleseren, lær deg Javascript; hater du deg selv, sett deg ned med Brainfuck (jeg beklager språket).

I dette faget kommer vi til å bruke språket Python. Python er et populært språk av mange grunner, og dets populæritet gjør at man kan bruke det innenfor mange fagdisiplinerer. En av fordelene med Python, er at overgangen fra /pseudokode/ til kjørende program ofte er lite. Under ser vi pseudokoden fra tidligere oversatt til Python.
#+BEGIN_SRC python :exports both
a = 5
b = 3
svar = 0

while b > 0:
    svar = svar + a
    b = b - 1

print(svar)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
15
#+END_SRC

** Ulike typer programmeringsspråk
I teorien kan alle programmeringsspråk som er såkalt [[popup:Etter Alan Turing, av «The Imitation Game»-berømmelse][/turingkomplette/]] beregne alt som kan beregnes. For at et språk skal være turingkomplett, må det litt forenklet ha mulighet til å gjenta kode om en betingelse ikke er nådd og kunne skrive og lese fra minnet. Dette gjelder i praksis alle programmeringsspråk.

Allikevel er det en voldsom forskjell på de ulike språkene. Et klassisk eksempel de fleste programmere har vært innom, er å få maskinen til å si "Hello, world!". La oss se på det for tre ulike språk.

*** «Assembly»
#+BEGIN_SRC asm

	extern exit, printf

	section .data
	msg db "Hello World!", 10, 0

	section .text
	global main
main:
	push msg
	call printf

	mov dword [esp], 0
	call exit
#+END_SRC

/Assembly/ er ikke ett programeringsspråk, men en samlebetegnelse for språkene skrevet spesifikt for hver CPU-type. Språket brukt over (hentet fra [[https://gist.github.com/Overv/5714335][denne]] snutten) er ment for den såkalte x86-arkitekturen.

*** C
#+BEGIN_SRC C :exports code :results raw
#include<stdio.h>

int main() {
  printf("Hello, world!");
  return 0;
}
#+END_SRC

/C/ er et klassisk programmeringsspråk og det dukker opp mer eller mindre over alt.

*** Python
#+BEGIN_SRC python :exports code :results silent
print("Hello, world!")
#+END_SRC

Den vanligste utgaven av Python er skrevet i C.

*** Høynivå og lavnivå
Vi ser tydelige forskjeller på eksemplene over. Assembly-koden ligger nære de instruksjonene CPU-en sjøl trenger for å kunne skrive «Hello, world!» på skjermen, mens Python-koden mer eller mindre bare repeterer oppgaveteksten.

Vi sier at assembly er /lavnivå/-kode, siden man må bruke ressurser på for eksempel direkte minnehåndtering når man skriver i det.  Python derimot er /høynivå/-kode, hvor brukeren ikke behøver tenke på slikt. /C/ legger seg et sted mellom de to. 

*** Imperative og deklarative kode
Felles for de tre eksemplene over er at vi for hver linje i koden forteller programmet hva det skal gjøre, vi sier at kodestilen er /imperativ/.

Et alternativ til imperativ kode er /deklarativ/ kode. Da forteller vi programmet kun hva vi har lyst på, ikke nødvendigvis hvordan vi ønsker at problemet skal løses. 

Under kommer to python-løsninger til oppgaven «lag en liste med de 100 første kvadrattaellene».

#+BEGIN_SRC python
n = 1                         # sett verdien av n til 1
kvadrattall = []              # sett verdien av kvadrattall til []
while n <= 100:               # gjør den kommende snutten så lenge n er mindre eller lik 100
    kvadrattall.append(n * n) # tilføy n * n i kvadrattall
    n += 1                    # øk verdien til n med 1
#+END_SRC

#+BEGIN_SRC python
kvadrattall = list(map(lambda x: x ** 2, range(1, 101)))
#+END_SRC

Her er det mange ord du ikke har sett før. Noen av dem kommer du til å bli svært godt kjent med, mens andre skal få lov til å holde seg obskure en god stund til. Med dette eksempelet ønsket jeg å illustrere at man innad i ett programmeringsspråk kan skrive innenfor mange ulike stiler.

Noen språk egner seg dog bedre til visse stiler, vi kommer i all hovedsak til å skrive /imperativ/ kode i Python.
** Semantikk og syntaks                                                            :noexport:
:LOGBOOK:
CLOCK: [2018-07-29 søn. 09:49]--[2018-07-29 søn. 10:21] =>  0:32
:END:
Hvert programmeringsspråk har et sett med «primitive constructs» (Guttag, s. 4), en syntaks, statisk semantikk og semnantikk. Om vi tenker på et naturlig språk (f.eks. norsk) er /primitivene/ ord, syntaksen forteller oss hvilke ord som lager velformede setninger, den statiske semantikken definerer hvilke setninger som er meningsfulle, og semantikken forteller til slutt hva meningen til de setningene er.

I Python har vi blant annet primitivene /literals/ (f.eks. tallet ~42.3~ og tekststrengen ~hei på deg~, og [[popup:%C2%ABinfiks%C2%BB%20fordi%20vi%20setter%20dem%20inn%20/mellom/%20to%20verdier][/infiksoperatorer/]] som ~+~ og ~*~). På norsk er tekststrengen «Stol hodet kne.» ikke en syntaktisk gyldig setning, siden vi på norsk ikke kan ha setninger på formen ~<substantiv> <substantiv> <substantiv>~. I Python er sekvensen av primitiver ~3.2 + 42.3~ syntaktisk velformulert, mens sekvensen ~3.2 42.3~ ikke er det.

Den statiske semantikken forteller oss hvilke syntaktisk korrekte sekvenser som faktisk gir mening. På norsk er sekvensen «kua er store» på formen ~<subjekt> <verbal> <adverbial>~, noe som er en syntaktisk akseptabel setning, men ~kua~ er i entall og ~store~ viser til flertall, så det er fremdeles ikke gyldig norsk. Dette er da en statisk-semantisk feil. I Python er sekvensen ~42.3 / "hei på deg"~ syntaktisk gyldig, men den gir en statisk semantisk feil siden det ikke gir mening å dele et tall på en tekststreng.

Semantikken i et språk assosierer en betydning til hver syntaktisk gyldige setning. I naturlige språk kan semantikken være tvetydig. Er for eksempel setningen «Jeg kan ikke si nok fine ting om deg» flatterende eller fornærmende? Programmeringsspråk er laget slik at enhver «lovlige» setning kun har én semantisk tolkning, de er entydige.

Når man begynner med programmering, er flesteparten av feilene man produserer såkalte syntaksfeil.

#+BEGIN_SRC python :exports both :results output raw
3.2 42.3
#+END_SRC

#+RESULTS:
#+BEGIN_SRC
  File "<stdin>", line 3
    3.2 42.3
           ^
SyntaxError: invalid syntax
#+END_SRC

Noen programmeringsspråk, som C og Java, gjør en stor grad av statisk-semantisk kontrollering av programmene, Python gjør (dessverre, mener mange) ikke dette.

Siden korrekte programmer er entydige, snakker vi sjelden om at programmer har semantiske feil. At de er entydige betyr dog ikke at programmet «betyr» det programmererer mente at det skulle da hun skreiv det. Når et program «betyr» noe annet enn det programmerer mente, kan det skje det dårlige ting.

Når et program har feil, og oppfører seg på en utilsiktet måte?

- Det kan kræsje, altså stoppe å fungere og gi en melding som gjør det tydelig at dette har skjedd. Om operativsystemet vårt fungerer som det skal, påvirker ikke dette systemet for øvrig. Allikevel har nok de fleste av oss vært borti at vi må restarte maskinen på grunn av et program som har kræsjet.
- Det kan fortsette å kjøre og kjøre og kjøre /ad infinitum/. Om vi ikke veit omtrent hvor lang tid programmet i utgangspunktet skulle bruke på jobben, kan dette være vanskelig å kjenne igjen.
- Det kan fullføre jobben sin og gi et svar som kanskje eller kanskje ikke er korrekt.

Av disse tre feiltypene, hvor alle er uønsket, er uten tvil den siste den verste. Det er her formuer tapes, biler kjører av veien, pasienter blir gitt for høye doser stråling og fly går i bakken.

Når mulig, bør programmer skrives på en slik måte at om de ikke fungerer på den måten man har tenkt at de skal, skal dette være tydelig. Vi kommer til å forsøke å legge inn systemer som passer på dette gjennom det følgende arbeidet.

#+BEGIN_TASK
Dataprogrammer er til tider plagsomet bokstavelige.

Du har to punkter på et kart. Forsøk å beskrive et program, en algoritme, som skal få deg fra det ene punktet til det andre i bil.

Hvor mange fartsbøter ville programmet ditt fått?
#+END_TASK

* Datamaskinen                                                                      :noexport:
** Historikk                                                                       :noexport:
*** Claude Shannon
*** Alan Touring
*** Jon von Neumann

** Logikk                                                                          :noexport:
*** Syllogismer
*** Boolsk

** En minneblokk fra logiske porter                                                :noexport:

** Verdier
*** Totallssystemet
Til hverdags bruker vi, selv «datafolk», titallssystemet. Vi bruker ti ulike siffer, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, til å angi hvor mange man har av den /tierpotensen/ plasseringen til sifferet står på, altså /koeffisienten/ til hver tierpotens. Til slutt legger vi sammen alle disse tierpotensene.

La oss se på hvordan tallet 1020304 er bygd opp i titallsystemet.

#+BEGIN_EXAMPLE
1020304 = 1 * 10^6 + 0 * 10^5 + 2 * 10^4 + 0 * 10^3 + 3 * 10^2 + 0 * 10^1 + 4 * 10^0
#+END_EXAMPLE

Her har vi altså /én/ million, /null/ hundretusener, /to/ titusener, /null/ tusener, /tre/ hundrere, /null/ tiere, og /fire/ enere. Vi leser det sjølsagt som «énmilliontjuetusenogfire».

Minnet til en datamaskin er satt sammen av en lang rekke elektriske ledere det enten går eller ikke går strøm i, de er enten /på/ eller /av/, 1 eller 0. Datamaskiner flest jobber altså i et /totallssystem/.

#+BEGIN_EXAMPLE
10100101 = 1 * 2^7 + 0 * 2^6 + 1 * 2^5 + 0 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 128 + 32 + 4 + 1 = 165
#+END_EXAMPLE

Verdien 10100101 i totallsystemet er altså 165 i titallsystemet, vi kan skrive det som (1010010)_2 = (165)_{10}.

Vi kaller en 1-er eller 0-er, en /bit/. En samling av åtte bits kaller vi en /byte/.


#+BEGIN_TASK
Regn følgende bytes over til titallssystemet:

00000111

10101010

10000011

11111111
#+END_TASK

*** Håndtering av desimaltall                                                     :noexport:
Vi har nå sett på hvordan en datamaskin kan representere tallene 0 og 1 via ledninger det ikke går eller går strøm i, og hvordan disse 0-ene og 1-erne kan brukes til å bygge opp alle heltall ved hjelp av totallssystemet.

Hva så med tallet 0.5? Hva med [[popup:når vi snakker om programmering, mener vi titallssystemet når vi sier «desimaltall», om vi ønsker å si «tall med komma», kaller vi det flyttall][flyttallene]]?

Flyttall representeres i all hovedsak som en slags variaent av tall på standardform når det er i minnet. I Python er det holdt av 64 bits til hvert flyttall. Når vi programmerer, må vi kan det dog være nødvendig å passe på når vi jobber med flyttall, da det her blir tydelige forskjeller på to- og titallssystemene.

Vi kommer ikke her til å gå nærmere inn på akkurat hvordan verdiene er lagret i maskinen (ønsker du å grave deg ned i dette, er [[https://en.wikipedia.org/wiki/IEEE_754][Wikipedia]] en fin ressurs), men ser vi på noe så enkelt som verdien 0.1 i Python, er verdien som Python /egentlig/ jobber med ørlite høyere, se under.

#+BEGIN_SRC python 
>>> 0.1
0.1000000000000000055511151231257827021181583404541015625
#+END_SRC

Til dagligdags regning, har ikke dette noe særlig betydning, vi må dog ha det i tankene når vi setter opp tester for ~if~-setninger, men mer om det seinere.

* Basispython
:PROPERTIES:
:CUSTOM_ID: basispython
:END:

** Regnerekkefølge og kommandolinja
:PROPERTIES:
:CUSTOM_ID: regnerekkefoelgeogkommandolinja
:END:

Siden Python-programmer kan oversettes til maskinkode løpende, kan vi jobbe /interaktivt/ med Python, à la slik vi er vant med fra CAS i Geogebra. Vi kan altså, om vi ønsker, skrive en linje med kode, se hva denne gjør, for så å skrive neste.

For å åpne en enkel Python-«prompt» (som er navnet på det som i vårt tilfelle tegnene «>>>»), kan du åpne kommandolinjeverktøyet ved å trykke windows-tasten og skrive «cmd», trykke enter, og skrive ~python~ og trykke enter i vinduet som åpner seg. Du skal få fram noe lignende følgende:

#+BEGIN_EXAMPLE
Python 3.6.1 |Anaconda 4.4.0 (64-bit)| (default, May 11 2017, 13:25:24) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>>
#+END_EXAMPLE

Hver gang du ser ~>>>~ «prompter» Python deg til å skrive inn en kommando.

Vanlige regneoperasjoner gjennomfører vi i Python på akkurat den måten man skulle forvente.

#+BEGIN_EXAMPLE
>>> 2 + 3                 # addisjon ved å skrive "+" mellom to verdier
5
>>> 2 - 3                 # subtraksjon ved å skrive "-" mellom to verdier
-1
>>> 2 * 3                 # multiplikasjon ved å skrive "*" mellom to verdier
6
>>> 2 ** 3                # eksponentiering ved å skrive "**" mellom to verdier
8
>>> 2 * (5 - 3 ** 2) ** 2 # regnerekkefølge oppfører seg på "vanlig" måte
32
#+END_EXAMPLE

Av disse er det kun potensen som skiller seg ut fra hvordan vi «vanligvis» skriver regning.

Du kan med andre ord begynne å bruke Python som en kalkulator uten mer om og men ... om enn kun å gjøre dette ville være å skrape den aller øverste delen av overflaten av hvilke muligheter et fullverdig programmeringsspråk byr på.

#+BEGIN_TASK
Prøv deg fram på vanlig tallregning i Python direkte i /interpreteren/.
#+END_TASK

** Variabler
:PROPERTIES:
:CUSTOM_ID: variabler
:END:

Vi kan nå gjennomføre enkle regneoperasjoner, men det melder seg raskt et behov for å kunne ta vare på resultatet fra en utregning, for så å kunne bruke dette i en annen utregning seinere. Dette kan vi gjøre via navngitte /variabler/.

*** Hva er et navn?
:PROPERTIES:
:CUSTOM_ID: hvaeretnavn
:END:
I Python viser navn alltid til verdier.

#+BEGIN_SRC dot :file ../figurer/navn_enkelt.png :cmdline -Kdot -Tpng :results silent
digraph {
rankdir=LR;'
navn [shape=cds, fontname="Open Sans"]
verdi [shape=circle, fontname="Open Sans"]

navn -> verdi
}
#+END_SRC

[[fig:navn_enkelt.png]]

I Python kan det godt være to navn på samme verdi.
#+BEGIN_SRC dot :file figurer/navn_dobbelt.png :cmdline -Kdot -Tpng :exports results
digraph {
rankdir=LR;
splines=True;
a [shape=cds, fontname="Open Sans"]
b [shape=cds, fontname="Open Sans"]
42 [shape=circle, fontname="Open Sans"]

a -> 42
b -> 42
}
#+END_SRC

#+RESULTS:
[[fig:navn_dobbelt.png]]

Python har /dynamiske typer/ noe som vil si at vi kan gjenbruke navn på helt andre type verdier enn hva de opprinnelig blei brukt på.

#+BEGIN_SRC python
a = 42
b = a
a = "Babel"
#+END_SRC

Som gir følgende navnstruktur:

#+BEGIN_SRC dot :file figurer/navn_rebundet.png :cmdline -Kdot -Tpng :exports results
digraph {
rankdir=LR;

a [shape=cds, fontname="Open Sans"]
b [shape=cds, fontname="Open Sans"]
42 [shape=circle, fontname="Open Sans"]
babel [shape=circle, fontname="Open Sans", label="\"babel\""]

b -> 42
a -> babel
}
#+END_SRC

#+RESULTS:
[[fig:navn_rebundet.png]]

Dette er i kontrast til et språk som C, hvor vi for eksempel ville sett følgende:

#+BEGIN_SRC C
int a = 42;
a = 42.0;
#+END_SRC

#+RESULTS:
#+BEGIN_SRC 
 warning: data definition has no type or storage class
 a = 43.0;
 ^
 warning: type defaults to 'int' in declaration of 'a' [-Wimplicit-int]
 error: redefinition of 'a'
 note: previous definition of 'a' was here
 int a = 42;
     ^
#+END_SRC

Dette er fordi C er et språk med /statiske/ typer. Det vil si at om vi har sagt at ~a~ skal være et heltall (~int~), må vi holde den som det gjennom hele programmet.
** Interaksjon
:PROPERTIES:
:CUSTOM_ID: interaksjon
:END:
*** Printing
:PROPERTIES:
:CUSTOM_ID: printing
:END:
Fra de fleste programmer ønsker vi en eller annen form for informasjon ut fra programmet. Dette kan være at programmet lager en graf for oss, at den skriver data til en fil, at interpreteren skriver svaret direkte på mellomregninger, eller at programmet skriver tilbake til kommandolinja.

Sistnevnte gjøres via funksjonen ~print~.

#+BEGIN_SRC python
print("Hei, verden!")
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Hei, verden!
#+END_SRC

Det er heller ikke noe i veien for å kombinere printing med variabler.

#+BEGIN_SRC python
a = 2
b = 3
c = a + b
print("Summen av ", a, " og ", b, " er ", c, ".")
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Summen av  2  og  3  er  5 .
#+END_SRC

Dette kan fort bli en uhensiktsmessig måte å skrive ut svar på, så vi bruker heller den innebygde formateringen ~f-strenger~.

#+BEGIN_SRC python
print(f"Summen av {a} og {b} er {c}.")
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Summen av 2 og 3 er 5.
#+END_SRC

~f-strenger~ er særegent for Python, men andre språk har gjerne sine måter å formatere tekstrestrenger på. Dette er et kraftig verktøy, hvor vi har store muligheter for å formatere svarene våre på en hensiktsmessig måte.

Vi kan, eksempelvis, spesifisere hvor mange desimaler vi ønsker. (Setningen ~from math import pi¨~ skal vi se i mye mer detalj på seinere.

#+BEGIN_SRC python
from math import pi
print(pi)
print(f'pi skrevet med 5 gyldige siffer er {pi:.5}.')
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
3.141592653589793
pi skrevet med 5 gyldige siffer er 3.1416.
#+END_SRC

Generelt kan vi spesifisere et tall som skal skrives ut ved å bruke tallets totale ~bredde~ og dets ~presisjon~ på en enkel måte med ~f-strenger~.

#+BEGIN_SRC python
bredde = 7
presisjon = 3
print(f'pi = {pi:{bredde}.{presisjon}}')
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
pi =    3.14
#+END_SRC

*** Input
:PROPERTIES:
:CUSTOM_ID: input
:END:
Å be brukeren om å taste inn verdier til programmet ditt kan enkelt gjøres ved å bruke ~input~-funksjonen. Om vi er usikre på hvordan denne brukes, kan vi benytte oss av pythons innebygde hjelpefunksjonalitet.

#+BEGIN_SRC python :exports both
help(input)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Help on built-in function input in module builtins:

input(prompt=None, /)
    Read a string from standard input.  The trailing newline is stripped.
    
    The prompt string, if given, is printed to standard output without a
    trailing newline before reading input.
    
    If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.
    On *nix systems, readline is used if available.
#+END_SRC

~input~ er altså en innebygd (/built-in/) funksjon som leser en tekststreng fra /standard input/. Dersom vi ønsker å gi brukeren en /prompt/, à la «>>>» kan vi gjøre det ved å gi det som argument til funksjonen.

#+BEGIN_SRC python
navn = input("Hva heter du? ")
print(f"Du heter {navn}." )
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Hva heter du? von Neumann    # Her har brukeren skrevet inn «von Neumann»
Du heter von Neumann.
#+END_SRC

** Typer
:PROPERTIES:
:CUSTOM_ID: typer
:END:
Et pythonprogram er et sett med instruksjoner som handler på ulike /objekter/. Objekter i Python kommer i to utgaver, skalare objekter og ikke-skalare objekter. Et skalart objekt er udelelig, det er /atomene/ i Python. Ikke-skalare objekter, for eksempel tekststrenger, har en indre struktur. Av de følgende, er /boolske verdier/, /heltall/ og /flyttall/ skalare objekter.
*** Boolske verdier
:PROPERTIES:
:CUSTOM_ID: boolskeverdier
:END:
I kapittelet [[file:datamaskinen.org][Datamaskinen]] introduserer jeg logiske verdier som enten kan være /sanne/ eller /usanne/. Disse er nødvendige for at vi skal kunne ha et fullstendig programerbart språk. Når vi seinere skal se på såkalte if-setninger, er vi nødt til å ha en måte å avgjøre om noe er sant eller usant på.

#+BEGIN_EXAMPLE
>>> sann = True
>>> usann = False
>>> sann
True
>>> usann
False
#+END_EXAMPLE


Boolske verdier oppstår ofte når vi ønsker å vurdere en påstand. Eksempelvis er det /sant/ at verdien 3 er større eller lik verdien 2, det er også Python enig i.
#+BEGIN_EXAMPLE
>>> 3 >= 2
True
>>> 3 == 2
False
>>> 3 < 2
False
#+END_EXAMPLE

Merk at ~=~ /ikke/ er en logisk sjekk, à la ulikhetene over. Om vi ønsker å sjekke for likhet, må vi bruke ~==~. ~=~ er fremdeles «tildelingoperatoren», vi bruker den for å gi ting navn, noe som betyr at det ikke er noe i veien for å gjøre for eksempel følgende i Python:

#+BEGIN_SRC python
sannhetsverdi = 3 > 2
print(sannhetsverdi)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
True
#+END_SRC

Her vil først Python /evaluere/ påstanden på høyre side, altså ~3 > 2~, finne at dette er sant, og dermed sette sannhetverdi til å ha verdien ~True~.
*** Heltall
:PROPERTIES:
:CUSTOM_ID: heltall
:END:
Heltall i Python oppgis på vanlig måte. ~3~, ~112~ eller ~1231421124~.
#+BEGIN_SRC python :exports none
import sys
print(sys.maxsize)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
9223372036854775807
#+END_SRC

*** Flyttall                                                                      :noexport:
:PROPERTIES:
:CUSTOM_ID: flyttall
:END:

*** Tekststrenger                                                                 :noexport:
:PROPERTIES:
:CUSTOM_ID: tekststrenger
:END:

*** Lister
:PROPERTIES:
:CUSTOM_ID: lister
:END:
Lister eller [[https://en.wikipedia.org/wiki/Array_data_structure][/arrays/]] er en klassisk datastruktur. Vi samler en rekke verdier inn i en liste, for at vi så skal kunne gjøre operasjoner på lista direkte eller elementvis. Lister lages i Python ved å bruke klamme-parenteser, ~[~ og ~]~, hvor hvert element er adskilt med komma.

#+BEGIN_SRC python
favorittall = [-1, 0, 7, 11, 42]
#+END_SRC

Det er heller ikke noe i veien for å ha noe annet enn tall i ei liste, ei heller blandede typer.

#+BEGIN_SRC python
frukter = ["eple", "pære", "appelsin", "mango"]
#+END_SRC

Innholdet i ei liste kaller vi enkeltvis for listas /elementer/, og hvert element er tildelt en /indeks/. Under ser vi nærmere på ~frukter~.

#+BEGIN_EXAMPLE
| element | eple | pære | appelsin | mango |
| indeks  |    0 |    1 |        2 |     3 |
#+END_EXAMPLE

Legg merke til at i Python er listene nullindeksert, altså har det første elementet i lista indeks 0.

#+BEGIN_SRC python
print(frukter[0])
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
eple
#+END_SRC

Vi kan hente ut elementer fra ei liste ved å bruke /slice/-notasjonen. Den ser ut som ~listenavn[første ønskede : ikke-inkludert siste ønskede : steglengde]~. Om vi har liste ~min_liste~ av ~n~ elementer, kan vi hente ut de ~k~ første ved å skrive ~min_liste[0:k:1]~, alternativt bruke at nullte element er standard startverdi og ~1~ er standard steglengde, ~min_liste[:k]~.

#+BEGIN_SRC python :exports both
print(frukter[0:2:1])
print(frukter[:2])
print(frukter[2:])
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
['eple', 'pære']
['eple', 'pære']
['appelsin', 'mango']
#+END_SRC

**** Muterbarhet
:PROPERTIES:
:CUSTOM_ID: muterbarhet
:END:
Se på følgende snutt, og skriv ned hva du tror vil bli gitt av print-setningen.
#+BEGIN_SRC python
a = ['mai', 'juni', 'juli', 'august']
b = a
a[1] = 'november'

print(f'a er: {a}')
print(f'b er: {b}')
#+END_SRC

Forsøk å kjøre koden, hva ser du? Jo, der vi forventer at vi ved linja ~b~ = ~a~ skal få en kopi av lista ~a~, ser det ut som at vi får to forskjellige navn til samme ting, og det er akkurat det vi får. En liste er en «muterbar» eller /mutable/ datastruktur i Python. Og hva vil så det si? Jo, der vi setter 

#+BEGIN_SRC ditaa :file figurer/mutable_lister_a.png
  +---+                  +------------------------------------+
  | a +----------------->|['mai', 'juni', 'juli', 'august']   |
  +---+                  +------------------------------------+
#+END_SRC

#+RESULTS:
[[fig:mutable_lister.png]]

#+BEGIN_SRC ditaa :file figurer/mutable_lister_a_b_forventet.png
  +---+                  +------------------------------------+
  | a +----------------->|['mai', 'juni', 'juli', 'august']   |
  +---+                  +------------------------------------+
                                                             
  +---+                  +------------------------------------+                                       
  | b +----------------->|['mai', 'juni', 'juli', 'august']   |                                       
  +---+                  +------------------------------------+
                                                             
#+END_SRC

#+RESULTS:
[[fig:mutable_lister_a_b_forventet.png]]

#+BEGIN_SRC ditaa :file figurer/mutable_lister_a_b_faktisk.png
  +---+                  +------------------------------------+
  | a +----------------->|['mai', 'juni', 'juli', 'august']   |
  +---+                  +------------------------------------+
                            ^
  +---+                     |
  | b +---------------------+
  +---+                 
                      
#+END_SRC

#+RESULTS:
[[fig:mutable_lister_a_b_faktisk.png]]

Og hvorfor er dette viktig? Jo, fordi verdier i lister kan endres uten at man oppretter en ny liste. Nå blir det vesentlig at navn i python /alltid/ viser til et objekt, og når vi sier ~b = a~ og ~a~ er en liste, får vi rett og slett bare ett nytt navn på ~a~.

Hvordan skal vi så gjøre det? Når vi skal kopiere en liste, kan vi gjøre dette ved å skrive ~b = a[:]~, siden /slicen/ ~a[:]~ er en ny liste med alle elementene i ~a~. Gjør vi dette igjen med snutten over, vil vi få ønske oppførsel.

#+BEGIN_SRC python
a = ['mai', 'juni', 'juli', 'august']
b = a[:]
a[1] = 'november'

print(f'a er: {a}')
print(f'b er: {b}')
#+END_SRC


#+BEGIN_SRC python
a = ['test']
b = a[:]
print(id(a))
print(id(b))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
1655628749000
1655628749192
#+END_SRC

#+BEGIN_SRC python
enere = [1, 1, 1, 1, 1]
print(id(enere))
enere += [5]
print(id(enere))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
1655628749192
1655628749192
#+END_SRC

#+BEGIN_SRC python
enere = "11111"
print(id(enere))
enere += "5"
print(id(enere))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
1655628510072
1655628511248
#+END_SRC

*** «Assosiasjonslister»                                                          :noexport:
:PROPERTIES:
:CUSTOM_ID: assosiasjonslister
:END:

** Oppgaver
:PROPERTIES:
:CUSTOM_ID: basispython-oppgaver
:END:
*** Kortoppgaver
:PROPERTIES:
:CUSTOM_ID: basispython-kortoppgaver
:END:
1. Be om et navn, skriv ut "Hei på deg, {navn}"    # Husk print("Hei på deg", navn)
2. Be om ett tall, skriv ut tallet opphøyd i andre.
3. Be om ett tall, skriv ut tre lavere enn tallet, så ganger to # Test med tall = 1 => -4
4. Be om ett tall, skriv ut det dobbelte av tallet i fjerde
5. Be om to tall, skriv ut summen av dem
6. Be om to tall, skriv ut produktet av dem
7. Be om to tall, skriv ut det første opphøyd i det andre
8. <<forrige>>Uten bruk av PC, hva blir...
   - ~2 + 2 ** 2~?
   - ~3 * 3 - 3~?
   - ~3 + 3 ** (3 * 3)~?
   - ~(3 - 3) ** 3~?
   - ~3 * 3 ** 3~?
   - ~4 + 4 % 4~?
   - ~5 // 4~?
   - ~5 / 2 * 5~?
9. Kontroller svarene dine i oppgave [[forrige]] ved å bruke Python.

* Abstraksjon
:PROPERTIES:
:CUSTOM_ID: abstraksjon
:END:
** Biblioteker
:PROPERTIES:
:CUSTOM_ID: biblioteker
:END:
*** Et fysikkbibliotek
#+BEGIN_EXAMPLE
tabaa004> python -m site --user-site
C:\Users\tabaa004\AppData\Roaming\Python\Python36\site-packages
#+END_EXAMPLE

Her legger jeg en kort fil som jeg kaller ~fysikk.py~. Dette skal på sikt være fysikkbiblioteket mitt. Her ønsker jeg å samle alle konstanter, samt en del formler og likninger jeg stadig ender med å bruke.

#+BEGIN_SRC python :exports both
import fysikk as fy

print(fy.g)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
9.81
#+END_SRC

Linja ~import fysikk as fy~ er vesentlig. Den består av to nøkkelord, ~import~ og ~as~; ett modulnavn, ~fysikk~; og ett alias, ~fy~.

En slik importeringssetning kommer vi til å se i de aller fleste programmene vi skal lage. Pythons motto er at det kommer «batteries included», men det betyr ikke at alt ligger tilgjengelig idet vi starter programmet, vi må /importere/ bibliotekene.

I eksempelet over er ~fysikk~ et slikt bibliotek. Vi kommer seinere til å bruke et knippe biblioteker, spesielt [[https://docs.python.org/2/library/math.html][~math~]], [[http://www.numpy.org/][~numpy~]], [[https://www.scipy.org/][~scipy~]], og [[https://matplotlib.org/][~matplotlib~]].

En del slike biblioteker er en del av Pythons /standardbibliotek/. Det vil enkelt og greit si at utviklerne av Python også tar seg av å holde disse modulene (les: bibliotekene) ved like. En del av standardbiblioteket er [[popup:Dette er funksjoner som er tilgjengelig uten noen form for ~import~-setning, f.eks. funksjonen ~sorted~, som sorterer ei liste][innebygde funksjoner]], men det er også egne moduler man må importere, slik som [[popup:~math~ trenger vi fort, dette biblioteket inneholder både ~sqrt~ og ~factorial~.][~math~]].

Vårt første møte ~import~-setninger blir også vårt første møte «punktnotasjon» eller /dot notation/. Vi skriver ~fy.g~ for vi ønsker å bruke ~g~ fra ~fysikk~-modulen, som vi her har valgt å gi kallenavnet («alias»-et) ~fy~. Vi ser av feilmeldingen under at om vi forsøker å bruke ~g~ direkte, får vi beskjed om at denne ikke er definert.

#+BEGIN_SRC python :exports both
import fysikk

print(g)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'g' is not defined
#+END_SRC

Vi kommer til å møte på punktnotasjonen i en situasjon til, for bruk av /metoder/ på /objekter/. Mer om det seinere.

*** Vårt typiske importoppsett
Du vil noen ganger se anbefalt å bruke en pakke som heter [[https://scipy.github.io/old-wiki/pages/PyLab][~pylab~]]. Dette er en samlepakke for tidligere nevnte ~scipy~, ~numpy~ og ~matplotlib~. Dette er en god pakke, men vi kommer ikke til å bruke den her. Grunnen er enkelt og greit at jeg mener den inviterer til dårlige vaner og at brukeren ikke må forholde seg til økosystemet hun jobber i. Pylab oppfordrer til å importere pakken via
#+BEGIN_SRC python
from pylab import *
#+END_SRC
hvor ~*~-markøren vil si «alt». Problemet med dette er at det nå ikke blir synlig for brukeren /hvor/ en funksjon, klasse eller variabel kommer fra. Det øker også sannsynligheten for at man ved uhell skriver over allerede-definerte navn.

Vi kommer til stort sett til å importere i det minste følgende:
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
#+END_SRC

Vi kommer også til å hente ut spesifikke funksjoner fra eksempelvis ~math~, noe vi kan gjøre via:
#+BEGIN_SRC python
from math import sqrt
import math
import numpy as np


liste = []
liste.exte
a = np.array([1, 2])
a.

print(sqrt(2))

help(liste.extend)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
1.4142135623730951
#+END_SRC

Legg merke til at vi her ikke lenger har behov for punktnotasjon når vi skal bruke ~sqrt~, da vi spesifikt har hentet ut denne fra ~math~-biblioteket.

** Funksjoner
:PROPERTIES:
:CUSTOM_ID: funksjoner
:END:
Vi har nå fått et knippe verktøy for å lage ulike variabler, men vi kommer snart til å se at vi gjentar oss selv mye i programmeringen. Som programmerer bør du være på utkikk etter kode som er gjentagelser av tidligere kode, dette kan som oftes samles i en egen blokk. Vi kaller slike gjenbrukebare blokker av kode for «funksjoner» eller «underrutiner» (/subrutines/).

#+BEGIN_SRC dot :file ../figurer/funksjon.png :cmdline -Kdot -Tpng :exports results
digraph {
// graph from left to right
rankdir=LR;
splines=true;
node [shape=box, fontname="Open Sans"];
edge [fontname="Open Sans"];

input [label="Inndata", style=invis]
funk [label="Funksjon"]
output [label="Utdata", style=invis]

input -> funk [label="Inndata"]
funk -> output [label="Utdata"]
}
#+END_SRC

#+RESULTS:
[[fig:funksjon.png]]

Vi har allerede brukt et par funksjoner, spesielt ~print~-funksjonen. Denne funksjonen har et navn (~print~), den tar inn ett eller flere argumenter (det som skal skrives) og den /gjør noe/ (skriver til skjermen).

*** Definisjon og kall
De to hovedtingene vi gjør med en funksjon er å definere den og å bruke (kalle) den. Definisjon skjer i Python ved å bruke nøkkelordet ~def~. Et kall fungerer ved at vi skriver funksjonsnavnet og en parentes som inneholder eventuelle paramtere.

#+BEGIN_SRC python
def hilsen():
    """En funksjon som sier 'hei'"""
    print('hei')
    return

def hilsen_navngitt(navn):
    """En funksjon som hilser på noe navngitt."""
    print(f'Hei, {navn}!')
    return

hilsen()
hilsen_navngitt('Trond')
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
hei
Hei, Trond!
#+END_SRC

Legg merke til at funksjonene over ikke /returnere/ noe. De gjennomfører setningene det de bler bedt om å gjøre, men gir ikke tilbake noen verdi.

I slike tilfeller kan vi enten skrive ~return~, ~return None~, eller la være å skrive noen retursetning overhodet.

#+BEGIN_TASK
Modifiser ~hilsen~ og ~hilsen_navngitt~ til heller å /returnere/ sine respektive tekststrenger.

Ønsket oppførsel er altså for eksempel:
#+BEGIN_SRC python :exports both
svar = hilsen_navngitt('Trond')
print(svar)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Hei, Trond!
#+END_SRC
#+END_TASK

*** Ord når vi snakker om funksjoner
En funksjon /defineres/ og i definisjonen tar funksjonen inn /argumenter/. Når vi /kaller/ funksjonen, kan vi sende /variabler/ inn som funksjonens /parametere/.

Strukturen på alle funksjonsdefinisjoner er som følger:

#+BEGIN_EXAMPLE
def funksjonsnavn(arg1, arg2, ...):
    """En beskrivelse av hva funksjonen gjør."""
    
    setninger hvor funksjonen gjør noe

    return det funksjonen skal returnere
#+END_EXAMPLE

La oss si vi ønsker å lage en funksjon som tar inn et tall og returnerer tallet kvadrert. Dette kan vi gjøre som vist under.

#+BEGIN_SRC python
def kvadrer(x):
    """Kvadrer tallet x."""
    svar = x * x
    return svar

print(kvadrer(2))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
4
#+END_SRC

I denne /definisjonen/ (markert med nøkkelordet ~def~), setter vi /navnet/ til funksjonen til å være ~kvadrer~, vi definerer ett argument ~x~, vi har en setning i /funksjonskroppen/ som lager en variabel som kun er synlig for funksjonen, ~svar~, som vi setter til å være ~x * x~, før vi avslutter med å returnere ~svar~. Til slutt /kaller/ vi funksjonen ved å skrive funksjonsnavnet, og å sende inn /parameteren/ ~2~.

#+BEGIN_TASK
Hva er /funksjonsnavnet/, /argumentene/ og /returverdi/ for funksjonen under?
#+BEGIN_SRC python :exports code
def snitt(a, b):
    """Gi gjennomsnittet av tallene a og b."""
    svar = (a + b) / 2
    return svar
#+END_SRC

Videre, i /funksjonskallet/ under, hva vil verdien av variabelen ~regnet_snitt~ være og hva er /parameterne/ i kallet?

#+BEGIN_SRC python :exports code
regnet_snitt = snitt(4.5, 9)
#+END_SRC
#+END_TASK

** Skop
:PROPERTIES:
:CUSTOM_ID: skop
:END:
Se på følgende programsnutt.

#+BEGIN_SRC python :exports both
n = 3

def inkrement(n):
    """Øk verdien til n med 1."""
    n += 1
    print(f'--Vi er inne i funksjonen.')
    print(f'--Verdien til n er nå {n}.')
    return n

inkrement(n)

print(f'Vi er på utsiden av funksjonen.')
print(f'Verdien til n er nå {n}.')
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org

--Vi er inne i funksjonen.
--Verdien til n er nå 4.
Vi er på utsiden av funksjonen.
Verdien til n er nå 3.
#+END_SRC

Her har vi først en /variabel/ kalt ~n~, som vi setter til verdien ~3~. Vi definerer så en /funksjon/ med /argument/ ~n~. Dette argumentet har ikke noe med variabelen å gjøre, argumentet gjelder kun for funksjonen, og blir opprettet idet funksjonen blir laget. Til slutt /kaller/ vi funksjonen 

Hva skjer så om vi kjører samme skript, bare med én vesentlig endring?

#+BEGIN_SRC python :exports code
n = 3

def inkrement(n):
    """Øk verdien til n med 1."""
    n += 1
    print(f'--Vi er inne i funksjonen.')
    print(f'--Verdien til n er nå {n}.')
    return n

n = inkrement(n)        # Obs!

print(f'Vi er på utsiden av funksjonen.')
print(f'Verdien til n er nå {n}.')
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org

--Vi er inne i funksjonen.
--Verdien til n er nå 4.
Vi er på utsiden av funksjonen.
Verdien til n er nå 4.
#+END_SRC

#+BEGIN_TASK
Kjør de to foregående programsnuttene og forklar eventuelle avvik mellom dem.
#+END_TASK

De delene av et program hvor en gitt variabel er tilgjengelig, kaller vi den variabelenes «skop», eller /scope/.

#+BEGIN_SRC python
x = 2
def utskrift():
    print(f'Inne i funksjonen er verdien til x {x}.')
    return

utskrift()

print(f'Utenfor funksjonen er verdien til x {x}.')
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Jeg skriver verdien av x, som  er 2.
#+END_SRC
#+BEGIN_SRC python

x = 2
def utskrift_med_indre():
    x = 3
    print(f'Inne i funksjonen er verdien til x {x}.')
    return

print(f'Utenfor funksjonen er verdien til x {x}.')
#+END_SRC

#+BEGIN_TASK
Hva blir skrevet av følgende program?

#+BEGIN_SRC python
def kvadrer(x):
    return x*x

def g(y):
    return y + 3

def h(y):
    return kvadrer(y) + 3

print h(2)
#+END_SRC

#+END_TASK

** Klasser
:PROPERTIES:
:CUSTOM_ID: klasser
:END:
Funksjonene er /verbene/ i programeringsspråket vårt. De /gjør/ noe med data og kan returnere verdier. Følger vi analogien videre, vil vi da kunne si at så langt er flyttallene, heltallene, listene, tuplene, tekststrengene, og assosiasjonslistene /subjektene/ i språket vårt. Vi har også sett hvordan vi kan lage nye verb ved å definere funksjoner, vi skal nå gå ett skritt videre ved å lage nye subjekter, klasser.

Området vi nå er på vei over i, kalles /objektorientert programmering/. Som nevnt tidligere, er det ikke strengt nødvendig med klasser for å kunne løse problemer, men det gjør mye av programmeringen langt enklere og mer oversiktlig. I tillegg virker klasser som et /abstraksjonsnivå/ mellom den som skriver og den som bruker et program.

#+BEGIN_SRC python :session kloss :exports code
  class Kloss(object):
      """En kloss som glir på et underlag og kan kollidere med andre klosser
      Klosser initieres med en masse, startposisjon og startfart, alle flyttall.
      """

      def __init__(self, masse, startposisjon, startfart):
          self.masse = masse
          self.posisjon = startposisjon
          self.fart = startfart
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
#+END_SRC

Det er kanskje ikke helt tydelig hva denne snutten gjør ennå. Her lager vi oss en ny /klasse/ som vi kaller ~Kloss~. Overse ~(object)~ inntil videre. Vi sier så at klossen skal lages, «initieres» med en masse, startposisjon, og startfart, alle disse er flyttall. Ønsker vi å lage en kloss med masse 1.0 kg, startposisjon 0.0 m og startfart 1.0 m/s, kan vi gjøre dette som 

#+BEGIN_SRC python :session kloss :exports both
kloss = Kloss(1.0, 0.0, 1.0)
print(type(kloss))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
<class '__main__.Kloss'>
#+END_SRC

Men ... hva skjedde med ~__init__~-argumentet ~self~? Vel, dette dukker opp gjennom hele klossens levetid som klossen selv. Når vi skal lage funksjoner for klossen (kalt «metoder») kommer vi til å bruke punktnotasjon for å kalle disse metodene.

Slik det står nå, er klossen vår en litt kjedelig sak, vi kan, om vi ønsker, hente ut egenskapene dens, men vi kan vanskelig få den til å gjøre stort. La oss gi den en måte å bevege seg på.

#+BEGIN_SRC python :session kloss_b
  class Kloss(object):
      """En kloss som glir på et underlag og kan kollidere med andre klosser
      Klosser initieres med en masse, startposisjon og startfart, alle flyttall.
      """

      def __init__(self, masse, startposisjon, startfart):
          self.masse = masse
          self.posisjon = startposisjon
          self.fart = startfart

      def beveg(self, delta_t):
          self.posisjon += self.fart * delta_t
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
#+END_SRC

#+BEGIN_SRC python :session kloss_b
kloss = Kloss(1.0, 0.0, 1.0)

t = 0
delta_t = 0.1

while t <= 1:
    kloss.beveg(delta_t)
    print(kloss.posisjon)
    t += delta_t
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
#+END_SRC

** Kjenn dine røtter
:PROPERTIES:
:CUSTOM_ID: kjenndineroetter
:END:
Av en eller annen grunn ønsker vi å finne nullpunktet til funksjonen $f(x) = 0.7e^{-x} - 5x + 13.$ Du setter deg ned med penn og papir, og innser raskt at du ikke kan det du behøver for å finne en /analytisk/ løsning til oppgaven (se f.eks. løsningen til [[http://www.wolframalpha.com/input/?i=0.7e%255E(-x)+-+5x+%252B+13+%253D+0][Wolfram Alpha]]).

Du tar derfor fram det digitale millimeterpapiret, Geogebra, tegner grafen, trykker «skjæring mellom to objekt», velger grafen og x-aksen og får opp at nullpunktet ligger ved $x=2.61$.

Hvordan gjør Geogebra dette?

Én måte å gjøre det på er ved hjelp av /halveringsmetoden/. Dette er en måte å finne et nullpunkt på, gitt at du veit følgende:
- to punkter på funksjonen
- at funksjonsverdien er negativ i ett av disse punktene
- at funksjonsverdien er positiv i det andre av disse punktene

Vår $f(x)$ er positiv i $x=0$ og negativ i $x=10$, så dette kan være gode startverdier.

Med dette på plass går algoritmen som følger:

#+BEGIN_EXAMPLE
a er en verdi hvor f(a) > 0
b er en verdi hvor f(b) < 0
eps er en bitte liten verdi, f.eks. 0.0001


hvis f( (a+b)/2 ) < 0
    sett b til å være (a+b)/2
ellers
    sett a til å være (a+b)/2
gjenta så lenge f( (a+b)/2 ) > eps
#+END_EXAMPLE

#+BEGIN_TASK
Her er det en gjentagende del. Om du skulle programmert dette ved bruk av en løkke, ville du brukt en ~for~- eller ~while~-løkke for å løse dette? Hvorfor?
#+END_TASK

For vår funksjon kommer gangen i dette til å se ut som følger:

#+BEGIN_SRC python :exports results
import math

def f(x):
    return 0.7 * math.exp(- x) - 5 * x + 13

def halvering(a, b, f, eps=0.0001):
    if f(a) < 0 and f(b) > 0:
        a, b = b, a
    if (f(a) < 0) == (f(b) < 0):
        raise ValueError("Samme fortegn på f(a) og f(b).")
    it = 0
    halveringsverdi = f( (a+b)/2)
    while abs(halveringsverdi) > eps:

        it += 1
        halveringspunkt = (a + b) / 2
        halveringsverdi = f(halveringspunkt)
        print(f"Iterasjon nr. {it}")
        
        print(f"a har verdien {a:.5}")
        print(f"b har verdien {b:.5}")
        if halveringsverdi < 0:
            b = halveringspunkt
        else:
            a = halveringspunkt
        print("--------------------")

    print(f"Svaret er {halveringspunkt:.5}.")
    return halveringspunkt

halvering(0.0, 10.0, f)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Iterasjon nr. 1
a har verdien 0.0
b har verdien 10.0
--------------------
Iterasjon nr. 2
a har verdien 0.0
b har verdien 5.0
--------------------
Iterasjon nr. 3
a har verdien 2.5
b har verdien 5.0
--------------------
Iterasjon nr. 4
a har verdien 2.5
b har verdien 3.75
--------------------
Iterasjon nr. 5
a har verdien 2.5
b har verdien 3.125
--------------------
Iterasjon nr. 6
a har verdien 2.5
b har verdien 2.8125
--------------------
Iterasjon nr. 7
a har verdien 2.5
b har verdien 2.6562
--------------------
Iterasjon nr. 8
a har verdien 2.5781
b har verdien 2.6562
--------------------
Iterasjon nr. 9
a har verdien 2.5781
b har verdien 2.6172
--------------------
Iterasjon nr. 10
a har verdien 2.5977
b har verdien 2.6172
--------------------
Iterasjon nr. 11
a har verdien 2.6074
b har verdien 2.6172
--------------------
Iterasjon nr. 12
a har verdien 2.6074
b har verdien 2.6123
--------------------
Iterasjon nr. 13
a har verdien 2.6099
b har verdien 2.6123
--------------------
Iterasjon nr. 14
a har verdien 2.6099
b har verdien 2.6111
--------------------
Iterasjon nr. 15
a har verdien 2.6099
b har verdien 2.6105
--------------------
Iterasjon nr. 16
a har verdien 2.6102
b har verdien 2.6105
--------------------
Iterasjon nr. 17
a har verdien 2.6102
b har verdien 2.6103
--------------------
Iterasjon nr. 18
a har verdien 2.6102
b har verdien 2.6103
--------------------
Svaret er 2.6103.
#+END_SRC

#+BEGIN_TASK
Forsøk å implementere halveringsmetoden for denne funksjonen i python. Du kan bruke funksjonsdefinisjonen

#+BEGIN_SRC python
import math

def f(x):
    return 0.7 * math.exp(- x) - 5 * x + 13
#+END_SRC

og sette startverdiene til 0.0 og 10.0.
#+END_TASK

** Oppgaver
:PROPERTIES:
:CUSTOM_ID: abstraksjon-oppgaver
:END:
*** Kortoppgaver
:PROPERTIES:
:CUSTOM_ID: abstraksjon-kortoppgaver
:END:
1. Lag en funksjon som dobler et tall
2. Lag en funksjon som halverer et tall
3. Lag en funksjon som legger sammen to tall
4. Lag en funksjon som kvadrer et tall
5. Lag en funksjon som opphøyer et tall i et annet
6. Lag en funksjon som returnerer en tekstrestreng ~n~ ganger

*** Samme utfall?
:PROPERTIES:
:custom_id: sammeutfall
:END:

Under vises definisjonen av to funksjoner. Beskriv forskjellen på de to funksjonene. Hvordan påvirker det bruken av dem?

#+BEGIN_SRC python
def addisjon_1(a, b):
    """Legg sammen to tall, a og b."""
    res = a + b
    print(f"Summen av a og b er {res}.")
    return None


def addisjon_2(a, b):
    """Returner summen av to tall, a og b."""
    res = a + b
    print(f"Summen av a og b er {res}.")
    return res

#+END_SRC

* Intermezzo: Tilfeldige tall
Å lage tilfeldige tall er vanskeligere enn man skulle tro. Det er kanskje ikke vanlig å kjøpe [[https://en.wikipedia.org/wiki/A_Million_Random_Digits_with_100,000_Normal_Deviates][bøker]] som kun inneholder tilfeldige tall lenger, det var kanskje aldri /vanlig/, men det er fremdeles et marked for /virkelig/ tilfeldige [[https://www.random.org/][tall]].

For den typen programmering vi er på vei til å begi oss ut på, kommer vi ikke unna å kaste noen digitale terninger eller stokke tilfeldig om på noen lister. Til dette kan vi bruke ~random~-biblioteket i Python. Dette gir oss ikke /virkelig/ tilfeldige tall, da de er produsert ved bruk av en algoritme, men såkalt /pseudo random numbers/ eller «tilsynelatende tilfeldige tall». Til vårt bruk er de mer enn gode nok.

Her har vi noen essensielle funksjoner, nevnt under. Vi kommer snart nok i situasjoner hvor vi trenger å bruke dem.

#+BEGIN_SRC python
import random as rnd

desimaltall = rnd.random()      # 'desimaltall' er nå i intervallet [0, 1)
terningkast = rnd.randint(1, 6) # 'terningkast' er nå i intervallet [1, 6]

alfabetisert = ['appelsin', 'eple', 'gulrot', 'pære', 'squash']
rnd.shuffle(alfabetisert)       # 'alfabetisert' er neppe alfabetisert lenger
#+END_SRC

Vi lar det være med det inntil videre.

* Programflyt
:PROPERTIES:
:CUSTOM_ID: programflyt
:END:
** Logikk
:PROPERTIES:
:CUSTOM_ID: logikk
:END:
Hvis ~a~ er sann og ~b~ er sann, så er ~a og b~ sann. Hvis ~a~ er sann, men ~b~ er usann, så er ~a og b~ usann.

Innenfor logikken, er ~og~ en svært viktig funksjon.

| Navn                  | Dagligtale  | Matematisk | Python |
|-----------------------+-------------+------------+--------|
| negasjon              | ikke        | ¬          | ~not~  |
| konjunksjon           | og          | ∧          | ~and~  |
| inklusiv disjunksjon  | og-eller    | ∨          | ~or~   |
| eksklusiv disjunksjon | enten-eller |            | ~xor~  |

*** Sannhetsskjemaer
:PROPERTIES:
:CUSTOM_ID: sannhetsskjemaer
:END:
I det følgende betyr 1 ~True~ og 0 ~False~.


#+CAPTION: Negasjon
| ~a~ | ~not a~ |
|-----+---------|
| <r> |     <r> |
|   0 |       1 |
|   1 |       0 |

#+CAPTION: Konjunksjon
| ~a~ | ~b~ | ~a and b~ |
|-----+-----+-----------|
| <r> | <r> |       <r> |
|   0 |   0 |         0 |
|   0 |   1 |         0 |
|   1 |   0 |         0 |
|   1 |   1 |         1 |

#+CAPTION: Inklusiv disjunksjon
| ~a~ | ~b~ | ~a or b~ |
|-----+-----+----------|
|   0 |   0 |        0 |
|   0 |   1 |        1 |
|   1 |   0 |        1 |
|   1 |   1 |        1 |

*** Regnerekkefølge
:PROPERTIES:
:custom_id: logikkregnerekkefoelge
:END:
I «vanlig» regning har vi en regnerekkefølge på operatorene som bestemmer om $2\cdot 3 + 1$ betyr $6 + 1$ eller $2\cdot 4$. Videre bruker vi parenteser for å endre regnerekkefølgen der nødvendig, eksempelvis ved å sette $2\cdot (3 + 1)$ om vi ønsker å ta addisjonen før multiplikasjonen her.

Det samme har vi behov for når vi jobber med logikk. For de vi er interessert i, «ikke», «og» og «eller», er rekkefølgen nettopp slik.
1. «ikke» -- ¬ -- ~not~
2. «og» -- ∧ -- ~and~
3. «eller» -- ∨ -- ~or~

Siden vi kommer til å gjøre langt mindre så kalt «boolsk algebra» enn vanlig regning, anbefales man å bruke parenteser for å fjerne eventuelle usikkerheter.

Vi kan da se på noen smårare eksempler ved å bruke de to enkle testene ~2 <= 3~ og ~3 < 2~ (henholdsvis ~True~, siden 2 /er/ mindre eller lik 3, og ~False~ siden 3 /ikke er/ mindre enn 2).

Test følgende i en Python-interpreter:

#+BEGIN_SRC python
if 2 <= 3 and 3 < 2 or 2 <= 3: # True and False or True
    print("Den første kjørte.")
else:
    print("Den første kjørte ikke.")

if 3 < 2 and 2 <= 3 or 2 <= 3: # False and True or True
    print("Den andre kjørte.")
    print("Den andre kjørte ikke.")
#+END_SRC

Merk, siden ~2 <= 3~ /evaluerer/ til ~True~ og ~3 < 2~ til ~False~, er det ingenting i veien for å endre eksempelet over til

#+BEGIN_SRC python
a = 2 <= 3
b = 3 < 2

if a and b or a:
    print("Den første kjørte.")
else:
    print("Den første kjørte ikke.")
#+END_SRC

** dersom ... så ...                                                                     :if:
:PROPERTIES:
:CUSTOM_ID: dersomsaa
:END:
Dersom vi ønsker at programmeringsspråket vårt skal kunne brukes til å regne ut alle beregnbare funksjoner, så må programmeringsspråket vårt ha en måte å ta avgjørelser på. Dersom språket vi har valgt er Python, så kan slike avgjørelser tas med en ~if~-setning.

Dersom du ønsker å skrive et program som kaster en mynt og sier om det blei kron eller mynt som landet opp, så kan du gjøre det som følger.

#+BEGIN_SRC dot :exports none :file figurer/if-setning.png :cmdline -Kdot -Tppng
digraph G {
        start [label="Ting gjøres...", shape=box, fontname="Open Sans"];
        if [label="Er noe sant?", shape=diamond, fontname="Open Sans"];
        ift [label="Gjør dette...", shape=box, fontname="Open Sans"];
        iff [label="Gjør dette...", shape=box, fontname="Open Sans"];

        start -> if
        if -> ift [label="Ja", fontname="Open Sans"];
        if -> iff [label="Nei", fontname="Open Sans"];
}
#+END_SRC

#+CAPTION: Et enkelt flytskjema for avgjørelser
[[fig:if-setning.png]]

Oversatt til pseudokode, kan dette uttrykkes

#+BEGIN_EXAMPLE
gjør ting

hvis noe er sant:
    gjør disse tingene
hvis ikke:
    gjør disse tingene
#+END_EXAMPLE

Om vi så ønsker å gjøre dette til en pythonsnutt som, for eksempel et program som «kaster en mynt» og forteller deg hva det fikk, kan det gjøres på følgende måte:

#+BEGIN_SRC python :exports both :session none
import random as rnd

myntkast = rnd.random()

if myntkast > 0.5:
    print('Jommen om det ikke blei kron denne gangen.')
else:
    print('Det blei visst mynt nå.')
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Det blei visst mynt nå.
#+END_SRC

En if-setning har altså følgende [[file:syntaksark.org::*~if~][syntaks]]:

#+BEGIN_SRC python
if boolsk():        # boolsk() defineres i syntaksark
    print("boolsk() ga sant")
else:
    print("boolsk() ga usant")
#+END_SRC

Dersom du ønsker at programmet skal gjøre noe om ~if~-en ikke inntraff, så kan du altså bruke ~else~.

En forenklet lærer sjekker kun poengsum og setter karakter deretter. Denne forenklede læreren har et oppsett som vises i tabellen under.

#+CAPTION: Poengskala
| Poeng | Karakter |
|-------+----------|
|  >=95 |        6 |
|  >=80 |        5 |
|  >=60 |        4 |
|  >=40 |        3 |
|  >=25 |        2 |
|   <25 |        1 |

Vi kan løse dette med ~if~ og ~else~ som vist under.

#+BEGIN_SRC python
import random as rnd

poeng = rnd.randint(0, 100)

if poeng >= 95:
    print('Læreren løfter hatten og gratulerer med karakteren 6!')
else:
    if poeng >= 80:
        print('Læreren gratulerer ydmykt med karakteren 5.')
    else:
        if poeng >= 60:
            print('Læreren tildeler deg herved karakteren 4.')
        else:
            if poeng >= 40:
                print('Læreren mener at karakteren 3 er å leve.')
            else:
                if poeng >= 25:
                    print('Læreren står i stolen for ståkarakten 2.')
                else:
                    print('Læreren ser fram til å se deg til neste år.')

#+END_SRC

Vi ser her at vi ender med å gjenta strukturen ~else: if..:~ gang på gang, og det baller på seg med innrykksnivåer. Som en kur til dette, har vi ~elif~-strukturen. Det samme programmet kan løses som under.

#+BEGIN_SRC python :exports both :session none
import random as rnd

poeng = rnd.randint(0, 100)

if poeng >= 95:
    print('Læreren løfter hatten og gratulerer med karakteren 6!')
elif poeng >= 80:
    print('Læreren gratulerer ydmykt med karakteren 5.')
elif poeng >= 60:
    print('Læreren tildeler deg herved karakteren 4.')
elif poeng >= 40:
    print('Læreren mener at karakteren 3 er å leve.')
elif poeng >= 25:
    print('Læreren står i stolen for ståkarakten 2.')
else:
    print('Læreren ser fram til å se deg til neste år.')
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Læreren mener at karakteren 3 er å leve.
#+END_SRC

** Mens vi venter                                                                     :while:
:PROPERTIES:
:CUSTOM_ID: mensviventer
:END:
Vi har allerede i [[file:introduksjon.org::*Valg%20av%20spr%C3%A5k][Valg av språk]] sett på ei ~while~-løkke. Denne bruker vi når vi ønsker at en programsnutt skal gjenta seg fram til en gitt betingelse er oppfylt. En ~while~-løkke består av nøkkelordet ~while~, et uttrykk som returnerer en [[file:variabler-datatyper.org::*Boolske%20verdier][boolsk]] verdi, og en eller flere setninger som skal kjøres.

#+BEGIN_SRC python
while uttrykk:
    setning(er)
#+END_SRC

Ønsker vi for eksempel å skrive ut alle heltall fra 1 til 10, kan det løses med en while løkke på følgende vis:

#+BEGIN_SRC python
tall = 1
while tall <= 10:
    print(tall)
    tall += 1
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
1
2
3
4
5
6
7
8
9
10
#+END_SRC

** Collatz' formodning                                                             :prosjekt:
:PROPERTIES:
:CUSTOM_ID: collatzformodning
:END:
Vurder følgende fremgangsmåte for et vilkårlig, positivt heltall, $n$:

- Hvis $n$ er et partall, del det på to
- Hvis $n$ er et oddetall, gang det med tre og legg til en

Collatz' [[popup:%C2%ABFormodning,%20innen%20matematikk,%20en%20antatt%20sann%20setning%20som%20enn%C3%A5%20ikke%20har%20blitt%20bevist.%C2%BB%20(Store%20norske%20leksikon)][formodning]] sier at om du så tar tallet du får gjennom samme prosess, og så tar tallet du får /da/ gjennom samme prosses, og så videre, og så videre, vil du til slutt få tallet 1. /Uansett/ hvilket positive heltall du startet på. En del tall har blitt sjekket, men ikke [[popup:Alle%20tall%20til%20$20\cdot2^{58}\approx%205.7646\cdot%2010^18$%20er%20sjekket.(https://sweet.ua.pt/tos/bib/3.5.html)][alle]].
Under vises rekka av collatz-tall om man starter på 17. Tall nummer to blir da 52, siden $1\cdot 3 + 1 = 52$.

#+BEGIN_SRC python :exports results :session none
# Snutt for å skrive ut 3n+1-tallene

n = 17
print(n, end=" ")
while n > 1:
    if n % 2 == 0:
        n = n // 2
    else:
        n = 3 * n + 1
    print(n, end=" ")
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
17 52 26 13 40 20 10 5 16 8 4 2 1 
#+END_SRC

Ta for gitt i denne oppgaven at ~n % 2 == 0~ er ~True~ dersom ~n~ er et partall, ~False~ hvis oddetall.

Bruk ~if~-setninger og en ~while~-løkke for å lage et program som gjør følgende:

- Ber brukeren om et positivt heltall, ~n~
- Skriver ut suksessive utregninger ~n~ basert på Collatz' formodning
- Slutter når ~n == 1~

** Fibonacci                                                              :prosjekt:noexport:
:PROPERTIES:
:CUSTOM_ID: fibonacci
:END:

#+BEGIN_SRC python :session none :exports results
import sys
a, b = 0, 1

while b < 1000:
    a, b = b, a + b
    print(a, end=" ")
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 
#+END_SRC

** Løpe gjennom ei liste                                                                :for:
:PROPERTIES:
:CUSTOM_ID: loepegjennomeiliste
:END:
*** ~for~-løkka
:PROPERTIES:
:CUSTOM_ID: for-loekka
:END:
Vi har en liste med alle tallene fra 1 til 10. For hvert av tallene ønsker vi å skrive ut hvorvidt tallet er delelig på 7.

#+BEGIN_SRC python
tallene = range(1, 10 + 1)

for tall in tallene:
    if tall % 7 != 0:
        print(f'{tall:2} er ikke delelig på 7.')
    else:
        print(f'{tall:2} er så visst delelig på 7.')
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
 1 er ikke delelig på 7.
 2 er ikke delelig på 7.
 3 er ikke delelig på 7.
 4 er ikke delelig på 7.
 5 er ikke delelig på 7.
 6 er ikke delelig på 7.
 7 er så visst delelig på 7.
 8 er ikke delelig på 7.
 9 er ikke delelig på 7.
10 er ikke delelig på 7.
#+END_SRC

I dette eksempelet brukte vi ei ~for~-løkke. Ei slik løkke gjør noe for hvert element i ei liste, eller noe annet det kan /itereres/ over.

*** Listegenerering                                                      :avansert:noexport:
:PROPERTIES:
:CUSTOM_ID: listegenerering
:END:
Nå som vi kjenner ~for~-løkka, kan vi se på en avansert måte å lage lister på, ved hjelp av et pythonverktøy kalt [[file:syntaksark.org::*%C2%ABList%20comprehension%C2%BB][/list comprehension/]].

#+BEGIN_SRC python
oddetallene = [i for i in range(1, 11) if i % 2 != 0]

kvadrattallene = [sum(oddetallene[:i+1]) for i in range(len(oddetallene))]

for kvadrattall in kvadrattallene:
    print(kvadrattall)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
1
4
9
16
25
#+END_SRC

** Oppgaver
:PROPERTIES:
:CUSTOM_ID: programflyt-oppgaver
:END:
*** Kortoppgaver                                                                  :noexport:
:PROPERTIES:
:custom_id: programflyt-kortoppgaver
:END:
1. Lag sannhetsskjema for $\neg a \wedge b$

*** abc-formelen
:PROPERTIES:
:custom_id: programflyt-oppgaver-abc
:END:
En generell andregradslikning kan skrives på formen \[ax^2 + bx + c = 0\]

Egenskapene til en andregradslikning bestemmes av /diskriminanten/. (Denne dukker gjerne opp som $d=b^2 - 4ac$.) Vi har følgende muligheter for en andregradslikning:
- $d>0$ :: Andregradslikningen har to løsninger
- $d=0$ :: Andregradslikningen har én løsning
- $d<0$ :: Andregradslikningen har ingen reelle løsninger

**** a - Antall løsninger
Lag et program som skriver ut /antallet løsninger/ på en andregradslikning spesifisert av brukeren. Du kan velge å ta utgangspunkt i den delvise løsningen under.

#+BEGIN_EXPORT html
<label for="toggle-1">Vis løsning: </label>
<input type="checkbox" id="toggle-1">
#+END_EXPORT
#+BEGIN_LOESNING
#+BEGIN_SRC python
from math import sqrt

a = input("a: ")
b = input("b: ")
c = input("c: ")

d = None # endre None til å regne ut diskriminanten

if d > 0:
    # Hva ønsker du at skal skje hvis d er positiv?
    print(None) # fjern denne linja

# Her mangler det en elif- og en else-setning

    
print("Ferdig")
#+END_SRC
#+END_LOESNING

**** b - Verdien til løsningene
Utvid programmet fra [[*a - Antall l%C3%B8sninger][a]] til også å gi x-verdiene til løsningene

**** c - Faktoriseringen                                                       :utfordring:
Utvid programmet fra [[*b - Verdien til l%C3%B8sningene][b]] til å skrive ut hva andregradslingen er faktorisert. En mulig bruk av programmet kan altså da se ut som følger:

#+BEGIN_EXAMPLE
Gi a: 3
Gi b: 3
Gi c: -18

Du ga andregradslikningen 
Den kan faktoriseres 3(x - 2)(x + 3)
#+END_EXAMPLE
*** 7-ern



:PROPERTIES:
:CUSTOM_ID: programflyt-oppgaver-7ern
:END:
Skriv et program som teller oppover fra 1. Få programmet til å hoppe over tallene som er delelige på 7.

*** ~def utvid~
:PROPERTIES:
:CUSTOM_ID: programflyt-oppgaver-utvid
:END:
Lag en funksjon, ~utvid~, med følgende spesifikasjoner:

#+BEGIN_SRC python
def utvid(liste1: list, liste2: list) -> list:
    """Returner sammenslåingen («concatination») av liste1 og liste2."""
    res = []

    # sett inn din kode her

    return res

#+END_SRC

*** ~def muterende_utvid~
:PROPERTIES:
:CUSTOM_ID: programflyt-oppgaver-muterendeutvid
:END:
Lag en funksjon, ~muterende_utvid~, med følgende spesifikasjoner:

#+BEGIN_SRC python
def muterende_utvid(liste1: list, liste2: list) -> None:
    """Utvider liste1 med elementene fra liste2.

    liste1 endres «in place».

    Returnerer None.
    """
    fo element in liste2:
        # sett inn din kode her

    return None
#+END_SRC

*** ~def glidelaas~
:PROPERTIES:
:CUSTOM_ID: programflyt-oppgaver-glidelaas
:END:
Lag en funksjon, ~glidelaas~, med følgende spesifikasjoner:

#+BEGIN_SRC python
def glidelaas(liste1: list, liste2: list) -> list:
    """liste1 = [elem1_0, elem1_1, elem1_2, ..., elem1_n]
    liste2 = [elem2_0, elem2_1, elem2_2, ..., elem2_n]

    return [(elem1_0, elem2_0), (elem1_1, elem2_1), (elem1_2, elem2_2), ..., (elem1_n, elem2_n)]
    """

    res = []
    
    # sett inn din kode her

    return res
#+END_SRC

*** ~def er_partall~
:PROPER TIES:
:custom_id: programflyt-oppgaver-erpartall
:END:
Lag en funksjon, ~er_partall~, med følgende spesifikasjoner:

#+BEGIN_SRC python
def er_partall(n):
    """Returner True hvis n er partall, False hvis ikke."""
    if test: # bytt ut 'test' med egen kode
        return True
    else:
        return False
#+END_SRC

*** Terningtipperen                                                           :miniprosjekt:
I denne oppgave bruker vi  ~random~-biblioteket ([[*Intermezzo: Tilfeldige tall][Intermezzo: Tilfeldige tall]]).

**** ~def terningkast~
Lag en funksjon, ~terningkast~, med følgende spesifikasjoner:

#+BEGIN_SRC python
def terningkast():
    """Returnerer et tilfeldig tall mellom 1 og 6."""
    tall = None # endre None slik at det er et tilfeldig tall mellom 1 og 6
    return tall
#+END_SRC

**** Ett forsøk
Lag et program som gjør følgende:
- Kaster en terning
- Lagrer verdien av kastet i en variabel
- Lar brukeren gjette på verdien
- Forteller brukeren om hun tippet riktig eller galt

**** Uendelig forsøk
Utvid programmet til å gjøre følgende:
- Gi brukeren uendelig med forsøk til å gjette verdien
- Skrive ut hvor mange forsøk hun brukte når hun tippet riktig

**** To forsøk
Utvid programmet til å gjøre følgende:
- Brukeren har to forsøk til å gjette verdien
- Programmet forteller brukeren «~For lavt~» dersom hun gjetter en for lav verdi, og «~For høyt~» om hun gjetter en for høy verdi


*** Fra ett til hundre                                                          :utfordring:
Lag et gjettespill som trekker et tilfeldig tall fra og med 1 til og med 100. Spillet skal ha følgende spesifikasjoner:
- Spillet skal kunne spilles så mange ganger man vil fram til man velger å avslutte (Tips: Man kan hoppe ut av en ~while~-løkke ved å bruke ~break~)-
- Spillet forteller deg om du har gjettet for høyt eller for lavt om du ikke gjetter riktig

La flere personer spille spillet ditt, og noter deg hvor mange forsøk de bruker. Eller se på [[#tekstfiler][Tekstfiler]]-kapittelet for inspirasjon til hvordan du kan holde en «high score»-liste.

* Plotting                                                                          :noexport:
:PROPERTIES:
:CUSTOM_ID: plotting
:END:
** Et enkelt linjeplot
:PROPERTIES:
:CUSTOM_ID: linjeplot
:END:

Først og fremst må vi /importere/ matplotlib-biblioteket. I de aller fleste programmer hvor du skal lage grafer, ønsker du følgende linjer i starten av programmet.

#+BEGIN_SRC python
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
#+END_SRC

Vi kan så gjøre i stand noen enkle data, for eksempel andregradsfunksjonen  $f(x)=x^2-3x+2$.

#+BEGIN_SRC python
x = np.arange(-10, 10, 0.01)
y = [x_i ** 2 - 3 * x_i + 2 for x_i in x]
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
#+END_SRC

I matplotlib jobber vi i hovedsak med to objekttyper, figurer (/figures/) og akser (/axes/). Vi kan opprette disse to objektene og lage grafen på følgende måte:

#+BEGIN_SRC python
fig, ax = plt.subplots()
ax.plot(x, y)
#+END_SRC

#+BEGIN_SRC python
fig.savefig("test.png")
#+END_SRC

* Tekstfiler
:PROPERTIES:
:CUSTOM_ID: tekstfiler
:END:
#+BEGIN_SRC ipython :exports none :results silent
import random as rnd
import numpy as np

def posisjon(t, fart=1.0, skalering=0.1, konstantledd=1.0):
    return fart * t + konstantledd + skalering * rnd.random()

starttid = 0
sluttid = 1.21
tidssteg = 0.01

tider = np.linspace(starttid, sluttid, int((sluttid-starttid)/tidssteg))
linjer = [(tid, posisjon(tid)) for tid in tider]

with open("data/posisjonseksempel.csv", mode='w+') as fil:
    for linje in linjer:
        fil.write(f"{linje[0]}, {linje[1]}\n")
#+END_SRC

Under ser du de ti første linjene fra ei fil med måledata fra en posisjonsmåling gjort med en enkel datalogger man har i de fleste fysikklasser. Dataene er lagret i en såkalt «csv»-fil (/comma-separated values/), en enkel tekstfil hvor dataene samles i kolonner med komma som skilletegn mellom verdiene i hver kolonne.

Du finner hele fila [[file:data/posisjonseksempel.csv][her]].

#+INCLUDE: "~/repos/promo/data/posisjonseksempel.csv" example :lines "-11"

~.py~-filene vi skriver når vi programmerer, ~.csv~-filene à la den vist over, eller ~.txt~-filer representeres bokstav for bokstav i dataminnet. Dette i kontrast til for eksempel ~.docx~-filene vi skriver i Word eller ~.xlsx~-filene vi jobber med i Excel. I tekstfiler kan vi gå byte for byte gjennom fila og finne tegn etter tegn, avhengig av hvilket kodesystem fila er skrevet med.

Dette gjør at slike filer er relativt enkle å lese inn og jobbe med i Python. For å jobbe med ei ~.docx~-fil i Python, trenger vi spesiallagde pakker, og ved neste korsvei kan Microsoft bestemme seg for å endre formatet filene er lagret i, og slike pakker vil ikke nødvendigvis lenger fungere.

** Lese inn tekstfiler
:PROPERTIES:
:CUSTOM_ID: leseinntekstfiler
:END:
Vi kan enkelt lese inn tekstfiler, som ~.csv~-fila over, i Python.

#+BEGIN_SRC ipython :session fil :results silent
posisjonsfil = open("data/posisjonseksempel.csv", "r")
#+END_SRC

Vi har nå fått et «filobjekt» kalt ~posisjonsfil~, som er koblet til fila over og åpnet kun med leserettigheter.

#+BEGIN_SRC ipython :session fil :exports both :results silent
filtekst = posisjonsfil.readlines()
#+END_SRC

~filtekst~ er nå en ~liste~ av tekststrenger, en for hver linje i fila.

#+BEGIN_SRC ipython :session fil :results output org
for linje in filtekst[:11]:
    print(linje)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Time(s), Position(m)
0.0, 1.0858895821272105
0.010083333333333333, 1.0985063603168348
0.020166666666666666, 1.1055806880912298
0.03025, 1.0338814312580846
0.04033333333333333, 1.1156353240231272
0.050416666666666665, 1.0937708416010385
0.0605, 1.0706124025902224
0.07058333333333333, 1.143944885230753
0.08066666666666666, 1.0941470792810783
0.09075, 1.118830320142538
#+END_SRC

Når vi åpner en file på denne måte, må vi huske å lukke den før vi avslutter programmet.

#+BEGIN_SRC ipython :session fil
posisjonsfil.close()
#+END_SRC

*** Alternativ innlesing                                                          :avansert:
:PROPERTIES:
:CUSTOM_ID: alternativinnlesing
:END:
For å unngå å måtte huske å lukke fila, kan vi alternativt jobb med fila innenfor en ~with~-kontekst, det foregående eksempelet blir da som følger:

#+BEGIN_SRC ipython :exports both :results output org
with open("data/posisjonseksempel.csv", "r") as posisjonsfil:
    filtekst = posisjonsfil.readlines()

for linje in filtekst[:5]:
    print(linje)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
Time(s), Position(m)
0.0, 1.0858895821272105
0.010083333333333333, 1.0985063603168348
0.020166666666666666, 1.1055806880912298
0.03025, 1.0338814312580846
#+END_SRC

** Plotting av data
:PROPERTIES:
:CUSTOM_ID: plottingavdata
:END:
Vi så i forrige kapittel på hvordan vi enkelt kan lage grafer ved hjelp av ~matplotlib~. Eksempelet under plotter dataene fra eksempelfila.

#+BEGIN_SRC ipython :results silent
import matplotlib.pyplot as plt

with open("data/posisjonseksempel.csv", "r") as posisjonsfil:
    filtekst = posisjonsfil.readlines()[1:]  # [1:] er for ikke å lese inn første linje

tider = []
posisjoner = []

for linje in filtekst:          # filtekst er her en liste av strenger
    tid, posisjon = linje.split(",")  # str.split(",") -> liste, elementer splittet ved ','
    tider.append(float(tid.strip()))
    posisjoner.append(float(posisjon.strip()))

plt.subplots()
plt.plot(tider, posisjoner)
plt.xlabel("Tid (s)")
plt.ylabel("Posisjon (m)")
plt.ylim(ymin=0)
plt.title("Posisjon i fysikkforsøk")
plt.savefig("figurer/posisjonseksempel_posisjon.png")
#+END_SRC

#+CAPTION: Plottet produsert i forrige eksempel
[[fig:posisjonseksempel_posisjon.png]]

** Skrive til tekstfiler
:PROPERTIES:
:CUSTOM_ID: skrivetiltekstfiler
:END:
Vi skal seinere kjøre simuleringer i egenskrevne programmer. Vi kommer da til å ha behov for å kunne lagre resultatene våre på en hensiktsmessig måte.

#+BEGIN_SRC ipython :results silent :exports code
import random as rnd

kasttittel = "Kast nr."
terningtitler = "Tern. 1, Tern. 2"
antall_kast = 10000

terningdata = open("data/terningeksempel.csv", "w")
terningdata.write(f"{kasttittel}, {terningtitler}")

for kast in range(antall_kast):
    tern1 = rnd.randint(1, 6)
    tern2 = rnd.randint(1, 6)
    linje = f"\n{kast+1}, {tern1}, {tern2}"  # se kommentar under
    terningdata.write(linje)

terningdata.close()
#+END_SRC

I linja ~linje = f"\n{kast+1}, {tern1}, {tern2}"~ skjer det to nevneverdige ting:
1. Vi starter linja med å sette inn ei ny linje ~\n~
2. Siden ~range~ starter på 0, legger vi til 1 på ~kast~ for å få kastene til å starte på nr. 1.


Etter å ha kjørt foregående snutt, ender vi med en innhold à la følgende:

#+INCLUDE: "~/repos/promo/data/terningeksempel.csv" example :lines "-11"

#+BEGIN_TASK
Endre terningeksempelet over til å skrive en fjerde kolonne, «Sum», hvor verdiene er summen av ~tern1~ og ~tern2~.
#+END_TASK
* Testing og bugs                                                                   :noexport:
:PROPERTIES:
:CUSTOM_ID: testingogbugs
:END:
** Testing
:PROPERTIES:
:CUSTOM_ID: testing
:END:

** Bugs
:PROPERTIES:
:CUSTOM_ID: bugs
:END:

* Appendiks: Prosjekter
:PROPERTIES:
:CUSTOM_ID: appendiks-prosjekter
:END:
** Største felles divisor                                                          :noexport:
:PROPERTIES:
:CUSTOM_ID: appendiks-prosjekter-gcd
:END:
Innenfor tallteori er to talls største felles divisor (/greates common divisor/) en vesentlig egenskap å kunne avgjøre. Målet med denne oppgaven er å lage en funksjoner ~sfd~, med to argumenter ~a~ og ~b~, som returnerer ~a~ og ~b~ sine største felles divisor.

*** Oppgave
Vi har et rom som er 221 dm bredt og 595 dm langt. Om vi skal flislegge gulvet i dette rommet med hele kvadratiske fliser, hva er den største sidelengden flisene kan ha?

*** En elementær tilnærming
For to tall, ~a~ og ~b~, hvor ~b < a~, kan deres /sfd/ være maksimalt ~b/2~.

#+BEGIN_TASK
Argumenter for foregående setning.
#+END_TASK

Dersom ~sfd(a,b) == 1~ har ~a~ og ~b~ /ingen/ felles divisorer større enn én, vi sier da at ~a~ og ~b~ /relativt primistiske/. For å finne en eventuell /sfd/ for ~a~ og ~b~, kan vi da teste alle tall fra 1 til ~b/2~.

#+BEGIN_SRC python
def sfd_elementaer(a, b):
    """Returner største felles divisor for heltallene a og b."""

    if a > b:
        a, b = b, a

    sfd = 1                     # Holder denne verdien er a og b relativt primistiske
    test = 1
    
    while test <= b/2:
        if a % test == 0 and b % test == 0:
            sfd = test
        test += 1

    return sfd
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
17
#+END_SRC

#+BEGIN_TASK
Denne testen er ineffektiv. Blant annet sjekker den alle partall, uavhengig av om ~a~ eller ~b~ er oddetall. Endre funksjonen til å være slik ~test~ økes med 2 i oddetallssteg (1, 3, 5, ...) dersom  enten ~a~ eller ~b~ er oddetall.
#+END_TASK

#+BEGIN_TASK
Lag en predikatfunksjon som svarer på hvorvidt ~a~ og ~b~ er relativt primistiske.
#+END_TASK

*** Kilder
[[https://no.wikipedia.org/wiki/St%C3%B8rste_felles_divisor][Største felles divisor]]

** Sykkeldata                                                                      :noexport:
:PROPERTIES:
:CUSTOM_ID: appendiks-prosjekter-sykkeldata
:END:

** Dating-algoritmen                                                               :noexport:
:PROPERTIES:
:CUSTOM_ID: appendiks-prosjekter-datingalgoritmen
:END:

** Twitter-boten
:PROPERTIES:
:custom_id: prosjekt_twitterboten
:END:

Gjennom dette prosjektet skal vi lage en «bot» som skal operere en twitter-konto. Til dette er det et par småting vi må ha på plass, vi må ha..

- registrert en twitter-konto boten skal få jobbe gjennom ([[https://twitter.com][twitter.com]])
- søkt om, og fått godkjent, kontoen som en «utvikler-konto» ([[https://developer.twitter.com][developer.twitter.com]])
- lagd en app som skal få jobbe mot vår nye utviklerkonto ([[https://developer.twitter.com][developer.twitter.com]])
- hentet autoriserings- og forbruker-kodene som blei laget for vår bot og twitter-konto

*** Oppsett
Registrer en konto på [[https://twitter.com][Twitter]]. Merk, dersom du ikke vil at boten skal tvitre fra din vanlige konto, om du har en, bør du her regisrtere en ny.

Deretter, gå gjennom [[https://developer.twitter.com/en/apply-for-access][Apply for access]] på [[https://developer.twitter.com][developer.twitter.com]]. Målet her er å få regisrtert brukeren din som en utvikler. Vær oppriktig i svarfeltene, om at du skal bruke kontoen i studeiesammenheng, og at du både vil søke opp andre tweets, samt sende ut dine egne.

Denne prosessen tar gjerne ti--femten minutter.

Du skal så lage en bot (eller «app») som skal få tilgang til å lese og skrive på twitter-kontoen din, også dette gjør vi på [[https://developer.twitter.com][developer.twitter.com]]. Trykk på nedtrekksmenyen ved navnet på kontoen din, og velg «[[https://developer.twitter.com/en/apps][apps]]». [[fig:twitterbot_appknapp.png]] Deretter velger du « «[[https://developer.twitter.com/en/apps/create][Create an app]]», hvor du skal fylle ut følgende om den kommende boten din:

| Hva?                                | Hvordan?                                                                                                                                                                                   |
|-------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ~App name~                          | Navnet på boten din. Jeg har kalt min «promo oppdateringsvarsel»                                                                                                                           |
| ~Application description~           | Hva skal boten din gjøre? Her kan du skrive  at du skal bruke den til et skolefag i programmering, om det er det du skal, og at den skal sende ut en liten mengde tweets og gjøre noen søk |
| ~Website URL~                       | Her må du fylle inn noe, men det er ikke så viktig hva du skriver. Om du har laget deg en github-konto, kan det være naturlig å ha URL-en til denne                                        |
| ~Enable sign in with twitter~       | Vi skal ikke lage en hjemmeside hvor brukerne skal kunne logge inn med twitterkonto, så denne trenger vi *ikke*                                                                            |
| ~Callback URLs~                     | Denne kan stå tom                                                                                                                                                                          |
| ~Terms of service URL~              | Denne kan stå tom                                                                                                                                                                          |
| ~Privacy policy URL~                | Denne kan stå tom                                                                                                                                                                          |
| ~Organization name~                 | Denne kan stå tom                                                                                                                                                                          |
| ~Organization website URL~          | Denne kan stå tom                                                                                                                                                                          |
| ~Tell us how this app will be used~ | Tilsvarende tidligere beskrivelser. Vær oppriktig og forklar det enkelt.                                                                                                                   |


Nå gjenstår det bare å finne autoriseringsnøklene som er blitt generert for boten vår. Vi har nå fått en ~App ID~, ~Consumer API keys~ (både en ~API key~ og en ~API secret key~), og to ~Access tokens~ (både en ~Access token~ og en ~Access token secret~). Om du velger Apps og din nylagde applikasjon nå, vil «Keys and tokens»-fanen ligne på det under, bare uten nøklene klipt bort.

[[fig:twitterbot_apptokens.png]]

Nå er det bare litt kode som gjenstår for å få våre python-genererte tweets ut i verden.

*** Botens første, spede steg
#+BEGIN_SRC python :exports code :session twitterbot :tangle ../py/twitter_oppdatering.py
import tweepy
import json

secrets_filename = 'oppdatering.secrets'

# oppdatering.secrets er ganske enkelt en fil som inneholder kodene twitter tildelte oss
# da vi registrerte boten vår. Innholdet i fila ser ut som noe à la dette (inkludert krøllparenteser:
# {
#      "OAUTH_TOKEN" : "0y1Fewz5D8r83r06848qGwB850rbf23fdascOZvxP2MVF0p63z9HZU-6z7",
#     "OAUTH_SECRET" : "2ae6zeVgY46g9JUKp2LLYobasdfQZsXDVAwQ4JQqhbvAR9hGzp",
#     "CONSUMER_KEY" : "DFWhHzNORWWIMjNnjosdfaSKV740Qq",
#     "CONSUMER_SECRET" : "pxpC6HUNGuqbsofgMz0VrxPD1BffASDfDGR12a6XAzDfPVNRRQl7Ngpt3J8BM"
# }
# Merk: Dette er sjølsagt ikke de faktiske kodene. De bør jeg, og du, holde hemmelig

api_keys = {}
with open(secrets_filename, 'r') as f:
    api_keys = json.loads(f.read())


auth = tweepy.OAuthHandler(api_keys['CONSUMER_KEY'], api_keys['CONSUMER_SECRET'])
auth.set_access_token(api_keys['OAUTH_TOKEN'], api_keys['OAUTH_SECRET'])
#+END_SRC

Det foregående ser mer komplisert ut enn det trenger å være, for deg, som ikke trenger å bekymre deg for at gud og hvermann skal kunne gå inn på nettsida du forsøker å lage og hente twitternøklene dine så de i en liten stund kan få gjøre hva de vil, kan koden se mer ut som følger:

#+BEGIN_SRC python :exports code :session twitterbot :tangle ../py/twitter_oppdatering.py
import tweepy

# bytt ut nøklene under med dine egne
OAUTH_TOKEN = "0y1Fewz5D8r83r06848qGwB850rbf23fdascOZvxP2MVF0p63z9HZU-6z7"
OAUTH_SECRET = "2ae6zeVgY46g9JUKp2LLYobasdfQZsXDVAwQ4JQqhbvAR9hGzp"
CONSUMER_KEY = "DFWhHzNORWWIMjNnjosdfaSKV740Qq"
CONSUMER_SECRET = "pxpC6HUNGuqbsofgMz0VrxPD1BffASDfDGR12a6XAzDfPVNRRQl7Ngpt3J8BM"

auth = tweepy.OAuthHandler(CONSUMER_KEY, CONSUMER_SECRET)
auth.set_access_token(OAUTH_TOKEN, OAUTH_SECRET)
#+END_SRC

Vi har nå fått python-programmet til å «logge seg på» twitter, med de rettighetene vi har gitt det. Vi bruker nå denne påloggingen til å opprette et ~api~-objekt, som vi skal benytte til å gjøre alle de tingene Twitter lar oss gjøre. 

Først og fremst, la oss «oppdatere statusen» vår, eller tvitre, som det også kalles. Det følgende skriver du i samme programsnutt som «innloggingen»: 

#+BEGIN_SRC python :exports code :session twitterbot :tangle ../py/twitter_oppdatering.py
api = tweepy.API(auth)
api.update_status('Hei på deg, verden!')
#+END_SRC

Resultatet av denne kodesnutten er tweeten under.

#+BEGIN_EXPORT html
<blockquote class="twitter-tweet" data-lang="en"><p lang="no" dir="ltr">Hei på deg, verden!</p>&mdash; promomunch (@promomunch) <a href="https://twitter.com/promomunch/status/1040655480618659842?ref_src=twsrc%5Etfw">September 14, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
#+END_EXPORT

*** ~api~-objektet
Over har vi linja ~api = tweepy.API(auth)~. Her skjer det mye. Fra venstre, har vi følgende:

1) Vi lager et variabelnavn, ~api~
2) Vi skal bruke noe fra ~tweepy~-modulen, ~tweepy.~
3) Fra tweepy skal vi bruke ~API~-klassen, ~API()~
4) For å lage en /instanse/ av ~API~-klassen, sender vi inn vår nye ~auth~-variabel. Denne kan du tenke på som «påloggingen» vår. Dette gjør at vi kan få boten vår til å jobbe med flere kontoer, om vi ønsker.

Tenk på hvordan denne linja henger sammen med en som er tilsynelatende mye enklere, utregningen av en kvadratrot.

#+BEGIN_SRC python :exports code
import math

tallet = 42
skurten = math.sqrt(tallet)
#+END_SRC

Ser du at linja ~skurten = math.sqrt(tallet)~ her inneholder akkurat de samme elemenetene som over? Den eneste prinsipielle forskjellen på disse to, er at vi med ~api =~-linja «kaller» ~API~-klassen, mens vi i ~skurten~ kaller ~sqrt~-/funksjonen/.

Der det vi får igjen av å kalle ~sqrt~-funksjonen er et tall, som vi kan gjøre Tallting™ med, får vi et ~API~-objekt av å kalle ~API~-klassen. ~API~-objektet (som her har fått /navnet/ ~api~), skal vi bruke til å gjøre Twitterting™ med, som å sende statuser, lese statuser, retweete og få venner.

Om vi ser på [[http://docs.tweepy.org/en/v3.5.0/api.html][hjelpedokumentasjonen]] til api-objektet, 
* Gjøremål                                                                          :noexport:
** TODO Opprette plotfunksjon for matematiske funksjoner
https://matplotlib.org/examples/pylab_examples/spine_placement_demo.html#pylab-examples-spine-placement-demo

** TODO Fortsette med tupler
   SCHEDULED: <2018-07-11 ons.>
   https://learnxinyminutes.com/docs/python/
   [[file:syntaksark.org::*Variabler%20og%20samlinger][Variabler og samlinger]]

** TODO Fjerne html-eksport fra toppen av sida.
[[file:~/repos/promo/org/promo.org]]

20180725 22:46

** TODO Popup fungerer bare for ett ord av gangen
https://www.w3schools.com/howto/howto_js_popup.asp

Dette var opprinnelig hentet fra w3schools. For berdre å få dette til få fungere, kan jeg sende en id-en til javascriptfunksjonen. Dette for å sørge for at alt er unikt.
* Notater                                                                           :noexport:
** Latex-chart

#+BEGIN_SRC latex :file fsa.pdf :packages '(("" "tikz")) :vorder 1em :results raw
\usetikzlibrary{shapes,arrows}
\tikzstyle{astate} = [circle, draw, text centered, font=\footnotesize, fill=blue!25]
\tikzstyle{rstate} = [circle, draw, text centered, font=\footnotesize, fill=red!25]

\begin{tikzpicture}[->, >=stealth', shorten >=1pt, auto, node distance=2.8cm, semithick]
  \node [astate] (1) at (0,0) {1};
  \node [astate] (2) at (1,0) {2};
  \node [rstate] (3) at (2m9) {3};
  \path (1) edge [bend left] node {b} (2)
  (2) edge node {b} (3)
  (2) edge [bend left] node {a} (1)
  (3) edge [loop above] node {(a, b)} (3);
  \end{tikzpicture}
#+END_SRC

** svarknapper
#+BEGIN_EXPORT html
<label for='txt'>static text
    <input type="text" id='txt' value="" />
</label>
#+END_EXPORT

** Arbeidsminnet i titallssystemet
I «arbeidsminnet» i en datamaskin, representeres koeffisientene som spenningsnivåer. Det ville her i utgangspunktet ikke vært noe i veien for å sette ti ulike spenningsnivåer, og dermed la datamaskinen jobbe med titallsystemet den òg. Problemet er da at det ville vært lite som skulle til for at en verdien var feil. Om vi setter minimumspenningen til 0 V og maksimumsspenningen til 5 V, får altså hver verdi et spenn på 0,5 V som er «sitt». Det skal da lite til at en verdi som 1,6 V faller under 1,5 V, og dermed at en 4-er brått er en 3-er.

** Partial
#+BEGIN_SRC python
from functools import wraps

def increment(whole_func):
    @wraps(whole_func)
    def wrapper(*args):
        return lambda x: whole_func(x, *args)
    return wrapper

@increment
def adder(x, y):
    return x + y

b = adder(3)
c = adder(2)
print(b(4))
print(c(9))       
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
7
11
#+END_SRC



** Twitter-bot
1. Lag en twitter-konto
2. Søk om å få den som /utviklerkonto/ på developers.twitter.com
